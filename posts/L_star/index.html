<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="L* 算法学习" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="本篇旨在记录自己学习L*算法的过程和理解。 参考： 吴礼发老师的《网络协议逆向分析及应用》 L*算法创世文：Learning Regular Sets from Queries and Counterexamples* 基于米利机的LM*算法：Reverse Engineering Enhanced State Models of Black Box Software Components to support Integration Testing 关于Model Learning的综述：Model Learning: A Survey on Foundation, Tools and Applications 对L*算法的理解和优化：Insights to Angluin’s Learning 找到的唯一一篇中文对L*算法的解释：模型学习 Angluins L*算法 学习笔记-wcventure" /><meta property="og:description" content="本篇旨在记录自己学习L*算法的过程和理解。 参考： 吴礼发老师的《网络协议逆向分析及应用》 L*算法创世文：Learning Regular Sets from Queries and Counterexamples* 基于米利机的LM*算法：Reverse Engineering Enhanced State Models of Black Box Software Components to support Integration Testing 关于Model Learning的综述：Model Learning: A Survey on Foundation, Tools and Applications 对L*算法的理解和优化：Insights to Angluin’s Learning 找到的唯一一篇中文对L*算法的解释：模型学习 Angluins L*算法 学习笔记-wcventure" /><link rel="canonical" href="https://gtrboy.github.io/posts/L_star/" /><meta property="og:url" content="https://gtrboy.github.io/posts/L_star/" /><meta property="og:site_name" content="gtrboy’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-07-27T17:20:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="L* 算法学习" /><meta name="twitter:site" content="@" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-07-30T08:41:51+08:00","datePublished":"2021-07-27T17:20:00+08:00","description":"本篇旨在记录自己学习L*算法的过程和理解。 参考： 吴礼发老师的《网络协议逆向分析及应用》 L*算法创世文：Learning Regular Sets from Queries and Counterexamples* 基于米利机的LM*算法：Reverse Engineering Enhanced State Models of Black Box Software Components to support Integration Testing 关于Model Learning的综述：Model Learning: A Survey on Foundation, Tools and Applications 对L*算法的理解和优化：Insights to Angluin’s Learning 找到的唯一一篇中文对L*算法的解释：模型学习 Angluins L*算法 学习笔记-wcventure","headline":"L* 算法学习","mainEntityOfPage":{"@type":"WebPage","@id":"https://gtrboy.github.io/posts/L_star/"},"url":"https://gtrboy.github.io/posts/L_star/"}</script><title>L* 算法学习 | gtrboy's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="gtrboy's blog"><meta name="application-name" content="gtrboy's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">gtrboy's blog</a></div><div class="site-subtitle font-italic">a dead beef</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/gtrboy" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['gtboy.dream','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>L* 算法学习</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>L* 算法学习</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> gtrboy </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Jul 27, 2021, 5:20 PM +0800" prep="on" > Jul 27, 2021 <i class="unloaded">2021-07-27T17:20:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Jul 30, 2021, 8:41 AM +0800" prefix="Updated " > Jul 30, 2021 <i class="unloaded">2021-07-30T08:41:51+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3916 words">21 min</span></div></div><div class="post-content"><blockquote><p>本篇旨在记录自己学习L*算法的过程和理解。 参考：</p><ol><li>吴礼发老师的《网络协议逆向分析及应用》<li>L*算法创世文：<a href="https://people.eecs.berkeley.edu/~dawnsong/teaching/s10/papers/angluin87.pdf">Learning Regular Sets from Queries and Counterexamples*</a><li>基于米利机的LM*算法：<a href="http://lig-membres.imag.fr/muzammil/documents/thesis/thesis.pdf">Reverse Engineering Enhanced State Models of Black Box Software Components to support Integration Testing</a><li>关于Model Learning的综述：<a href="https://arxiv.org/pdf/1901.01910.pdf">Model Learning: A Survey on Foundation, Tools and Applications</a><li>对L*算法的理解和优化：<a href="https://it.uu.se/research/publications/reports/2003-039/2003-039-nc.pdf">Insights to Angluin’s Learning</a><li>找到的唯一一篇中文对L*算法的解释：<a href="https://blog.csdn.net/wcventure/article/details/79144074">模型学习 Angluins L*算法 学习笔记-wcventure</a></ol></blockquote><h1 id="基础">基础</h1><hr /><h2 id="1-集合">1. 集合</h2><h3 id="集合连接ab">集合连接：A·B</h3><p>集合A={0,01}, B={1,10} A·B = {01,010,011,0110}</p><h3 id="克林闭包">克林闭包</h3><p>Σ是一个字母表集合，克林闭包（kleene Closure）Σ*=Σº∪Σ¹∪Σ²∪…，即Σ上所有字符串的集合。 如：{0,1}* = {ε，0，1，00，01，11，000，001，010，011，100，…}</p><h2 id="2-名词解释自动机相关">2. 名词解释（自动机相关）</h2><ul><li>alphabet 字母表：符号的有限集合。 记作： Σ 例如：{a, b, … , x, m}<li>strings 字符串： 通常我们用到建立在 Σ 上的字符串：有穷的符号序列。 例如：对于 Σ={a, b, c}, “ababc” 就是 Σ 上的一个字符串。<li>languages 语言：通常我们也只用建立在Σ上的语言，语言就是多个字符串的集合。例如 {ababc, ab, bc, ..}<li>sentences 句子：句子是语言集合中元素（字符串）的另一个称呼。<li>notation 符号：Σ* 是Σ上所有可能的字符串的集合。例如：Σ={a, b}, Σ* = { ε, a, b, ab, ba}</ul><h3 id="正则语言">正则语言</h3><p>我的理解：一个正则语言L是一个字母表克林闭包集合的一个子集。一个正则语言可以用一个确定有限自动机（DFA）来表示。</p><h3 id="前缀后缀闭合">前缀/后缀闭合</h3><ul><li>前缀闭合：对于一个string集A，如果A是前缀闭合的，当且仅当A中每个成员的每个前缀也是这个集合的成员之一。<li>后缀闭合：对于一个string集A，如果A是后缀闭合的，当且仅当A中每个成员的每个后缀也是这个集合的成员之一。</ul><h2 id="3-确定有限状态自动机dfsmdfa">3. 确定有限状态自动机（DFSM、DFA）</h2><p>确定有限自动机A是由：</p><ul><li>一个非空有限的状态集合Q<li>一个输入字母表Σ（非空有限的字符集合）<li>一个转移函数δ: Q×Σ-&gt;Q，例如：δ(q,σ)=p (p,q∈Q, σ∈Σ)<li>一个开始状态q0∈Q<li>一个接受状态的集合F∈Q</ul><p>所组成的5元组。表示为A = (Q,Σ,δ,q0,F)。一个正则语言可以用一个DFA表示。如：</p><ul><li>正则语言表示：L为长度为偶数的字符串组成的正则语言<li>DFA表示：状态机只接受长度为偶数的字符串，拒绝其它所有长度类型的字符串</ul><p>DFA状态转换图如下：</p><p><img data-proofer-ignore data-src="/img/L-star/even_string_case.png" alt="even_string_case" /></p><p>q0为初始状态，也为状态机最终接受的终止状态。</p><h2 id="4-米利型有限状态机mealy-machine">4. 米利型有限状态机（Mealy Machine）</h2><p>在DFA的基础上添加了输出（output），由六元组组成：(Q,I,O,δ,λ,q0)，构成自：</p><ul><li>非空有限状态集Q<li>q0∈Q为初始状态<li>I为有限输入符号集<li>O为有限输出符号集<li>δ: Q×I-&gt;Q 为状态转移函数<li>λ: Q×I-&gt;O 为输出函数</ul><p>相比于DFA，Mealy Machine将DFA中的Σ划分为有限输入输出符号集I/O，并增加了输出函数λ，状态迁移信息更加丰富。同时，DFA将状态区分为接受状态和拒绝状态（表示某个string是否被正则语言L接受），而Mealy Machine中的状态全部为接受状态，仅依据状态迁移过程中的输入输出序列区分状态。</p><p>可以看出，相比于DFA，Mealy Machine更适合表示协议状态机，因为协议是根据输入而响应，并且转移到下一个状态的模型。Mealy Machine应用于协议状态机的形式化描述时，I和O分别对应于抽象出来的输入和输出报文类型集，一个会话对应于一个I/O序列。</p><h1 id="l算法">L*算法</h1><hr /><p>L*算法于1987年由耶鲁大学教授Dana Angluin提出，详见<a href="https://people.eecs.berkeley.edu/~dawnsong/teaching/s10/papers/angluin87.pdf">Learning Regular Sets from Queries and Counterexamples*</a>。该算法的目标是通过不断请求和猜想，推断出目标黑盒系统的最小化DFA。</p><h2 id="成员查询和等价查询">成员查询和等价查询</h2><p><img data-proofer-ignore data-src="/img/L-star/L-star-concept.png" alt="obv-table" /></p><ul><li>membership query：一个来自Σ*中的string是否存在于目标正则语言中。每次查询返回的结果是1（accepted）或者0（rejected）。当通过成员查询完成了一个符合规范的观察表OT时，算法猜想出一个可能的状态机模型M。<li>equivalence query：通过向teacher（也有称作oracle）发起等价查询来验证上述猜测的模型M是否与黑盒系统一样。若teacher发现了一个反例（counterexample），则将反例返回给Learner，扩展OT表，并开启新一轮学习，直到teacher找不到反例为止。反例是一个被M接受但是被目标黑盒系统（SUT）拒绝的string，或者相反。被目标系统接受，说明string的字符序列使状态机达到了最终接受状态F；被目标系统拒绝，说明string的字符序列使状态机达到中间某状态，但并非最终接受状态。</ul><blockquote><p>关于该算法Learner的行为描述（摘自参考文献5）：</p><p>The typical behavior of a Learner is to start by asking a sequence of membership queries, and gradually build a hypothesized DFA M using the obtained answers. When the Learner feels that she has built a “stable” hypothesis M, she makes an equivalence query to find out whether M is correct. If the result is successful, the Learner has succeeded, otherwise she uses the returned counterexample to revise M and perform subsequent membership queries until arriving at a new hypothesized DFA, etc.</p></blockquote><h2 id="observation-tableot表">Observation Table（OT表）</h2><p><img data-proofer-ignore data-src="/img/L-star/obv-table.png" alt="obv-table" /></p><p>L*算法根据输出填充OT表。OT表中的概念：</p><ul><li>S：字母表Σ表示下的前缀闭合的字符串集合。预示当前学习程度中可能的状态。个人认为，保证S前缀闭合是为了避免跳过一些可能的状态，保持状态的连续性。<li>E：字母表Σ表示下的后缀闭合的字符串集合。E可以用来区分S状态。<li>S中元素s和E中元素e组成的字符串t = s·e，表示要向SUT查询的一个字符串。<li>OT表的行标签分为两部分，一部分为S，表示当前学习到的Model的状态，另一部分为S·Σ，用来表示状态的转移。行标签合并表示为S∪S·Σ。<li>OT表的列标签为E，用来区分不同的状态。<li>T为映射函数，T = (S∪S·Σ)×E -&gt; {0,1}，表示某个字符串t=s·e是否在SUT中存在（T(s,e)），通过membership query实现。如果字符串s·e被自动机D接受，则T(s,e)=1，否则=0。T函数的值就是OT表中需通过membership query查询的每个entry，每个entry就代表着learner向SUT查询过该对应string是否存在于正则语言L中。<li><strong>等价</strong>的定义：对于正则语言L，x和y是L中字符串（x,y∈Σ*），如果x，y等价，则对于Σ*中的任何串z，xz和yz要么都是L的句子，要么都不是L的句子。但是，在OT表的构建过程中，不可能总是遍历Σ*中的所有字串来判断等价关系。因此，需要在OT表的范围内约定一个等价的定义，即：假定s,t∈S∪S·Σ为OT表的两个行标签，s和t等价（s≌t）当且仅当对于所有的e∈E，T(s,e) = T(t,e)。相当于把Σ*中的任意串作为后缀改为了OT表列标签E中的任意项作为后缀，缩小了范围。因此，无法完全判断s和t究竟是否真的等价，但是可以通过一致性检查确定它们一定不等价。<li>需注意，在构建OT表的过程中，row(a)=row(b)表示a，b等价，它们属于同一个<strong>等价类（equivalence class）</strong>，但是也只是临时的等价，如果经过一致性检查发现它们不等价，那么需要将它们变成两个新的class。</ul><h3 id="ot表的闭合性和一致性">OT表的闭合性和一致性</h3><ul><li>闭合性（closed）：对于每一个t∈S⋅Σ，在S中都有一个对应的s使得row(s) = row(t)，我们称观察表（S,E,row）闭合。即<strong>rows(S·Σ)⊆rows(S)</strong>。意思是S·Σ域中每一行，在S域中都能找到对应的等价项。<strong>个人理解：闭合性含义是当前没有新的状态出现</strong>。<li>一致性（consistent）：如果每当有 w1,w2 ∈ S，有row(w1) = row(w2)，然后对于所有的 a∈Σ，有row(w1·a) = row(w2·a)，我们就称观察表是一致的。即<strong>row(s)=row(s’) =&gt; row(s·a)=row(s’·a)</strong>。意思是对于两个状态，如果它们等价，那么添加相同的后缀所组成的状态也一定等价。<strong>个人理解：这两个状态是等价的两个状态，可以合并</strong>。</ul><blockquote><p>个人理解：当L*算法认为推断出来的模型没有新状态产生，并且对于看上去相同的状态也可以确定它们是完全一致的（同一个等价类），就会认为猜测出了一个可能的Model。</p><ul><li>对于闭合性的检查，其目的是为了保证S·Σ中每一项都在S中有属于同一个等价类的项，并保证当前没有新的等价类出现，这样一来，在最后构建状态机时，就可以知道不同的状态转移（S·Σ中的行）会转移到具体哪个状态（S中对应的等价类状态）。<li>对于一致性的检查，其目的是为了保证S中每个等价类中的各项（状态）是真实等价的（个人认为，不能完全保证），即它们属于唯一的等价类，这样S·Σ中的状态转移才能对应到具体的某个确定的状态。</ul></blockquote><h2 id="学习过程">学习过程</h2><p><img data-proofer-ignore data-src="/img/L-star/L-star.png" alt="L-star" /></p><ul><li>当L*发现S中的s1和s2、E中的e以及Σ中的a，满足row(s1)=row(s2)但是T(s1·a·e)≠T(s2·a·e)，那么当前OT不是<strong>一致</strong>的，即两个所谓的等价类其实不是等价的。L*将a·e添加到E中，扩展并填充OT，用a·e来将两个等价类区分（distinguish）为两个新类。<li>当L*发现对于S·Σ中的t，满足row(t)和S中所有s的row(s)都不同，那么当前OT不是<strong>闭合</strong>的，表示存在新的状态。L*将t添加进S中，扩展并填充OT。扩展时将OT扩展至(S∪S·Σ)，也就是说，把t放入S之后，把t·a放入S∪Σ，其中a为Σ中所有项。因为如果row(t)和所有row(s)都不同，那么t可能是一个新的状态。<li>当L*认为OT已经满足一致性和闭合性，则认为猜想出一个Model M=(S,E,T)。<li>向teacher发起equivalence query，teacher检查M，如果发现并返回反例t，那么将<strong>t以及其前缀</strong>添加到S，并扩展S∪S·Σ，用成员查询扩展OT。重复上面步骤。<li>当teacher回复yes，则结束。</ul><h2 id="例子">例子</h2><p>来自参考文献3。DFA D如下图所示：</p><p><img data-proofer-ignore data-src="/img/L-star/case-dfa.png" alt="case-dfa" /></p><p>该DFA接受的正则语言L：<strong>所有包含偶数个（包括0）a以及偶数个（包括0）个b的字符串</strong>，其中q0为初始状态，也为结束状态，Σ = {a,b}。现在利用L*算法推测该DFA。首先构造初始OT表，如下图：</p><p><img data-proofer-ignore data-src="/img/L-star/case-init-ot.png" alt="case-init-ot" /></p><p>当前OT表是一致的（S中只有一项，不涉及等价的两项），但是并不闭合（row(a)≠row(ε)）。此时需要将S·Σ中的a添加到S当中，作为一个新的潜在状态。添加之后，S扩充为{ε,a}，接下来还要扩充S·Σ，将a·a和a·b添加到S·Σ当中。然后向SUT发起membership query，填充OT。填充后的OT如下图（左）所示：</p><p><img data-proofer-ignore data-src="/img/L-star/case-td2.png" alt="case-td2" /></p><p>当前OT是闭合（row(b)=row(a·b)=row(a)，row(a·a)=row(ε)）且一致（S中没有完全等价的两个row）的。因此算法认为猜测出来一个Model M1，如上图右所示。该M1包括两个状态。这里可以看到，b·b的结果其实是未知的。</p><p>接下来，Learner向teacher发起equivalence query。发现存在反例b·b，δ(q0,b·b)在teacher中返回q0（即[ε]），而在M1中返回到[a]。因此，L*将做以下三件事：</p><ul><li>将反例b·b添加到S中<li>同时还要将其前缀（b）也一并添加到S中，保持S的前缀闭合<li>扩展S·Σ，添加b·a、b·b·a以及b·b·b到S·Σ<li>向SUT发起membership query，填充OT</ul><p>经过上述步骤后，OT表被更新为如下所示：</p><p><img data-proofer-ignore data-src="/img/L-star/case-td3.png" alt="case-td2" /></p><p>可以看出，当前OT表为闭合的（S·Σ中所有row都能在S中找到对应等价项），但是不一致（row(a)和row(b)相同，但是T(a·a,ε)≠T(b·a,ε)）。算法将区分row a和row b的后缀a·ε=a添加仅E当中，并通过membership query填充OT。填充后的OT如下图所示：</p><p><img data-proofer-ignore data-src="/img/L-star/case-td4.png" alt="case-td2" /></p><p>可以看出来，此时OT是闭合且一致的。算法推测出右图的状态机M2。这里状态机的构建可遵循以下几点考虑：</p><ul><li>这里由于row(ε)和row(b·b)等价，它们在闭合且一致的条件下可以看做同一个状态，因此合并<li>E用来区分不同的状态，row(ε)={1,0}，row(a)={0,1}，row(b)={0,0}为三个不同的状态，其中row(ε)为起始状态，图中标记为[ε]。<li>S∪S·Σ中与上述三个状态等价的项，可以看做通过S∪S·Σ中的前缀转移到的同一个状态，如row(a·b)=row(b)，表示从初始状态经过a和b的输入，转移到了状态[b]，而row(a·a)=row(ε)表示从初始状态经过两次输入a，重新回到了初始状态</ul><p>接下来进行equivalence query，teacher返回了反例a·b·b。因为在M2下，δ(q0,a·b·b)=q0，但在原始DFA中，a·b·b并不会使状态机回到初始状态q0。将a·b·b及其所有前缀添加到S中，由于a已经在S中，因此将a·b和a·b·b添加到S中。之后扩展S·Σ，添加a·b·a，a·b·b·a，a·b·b·b。填充OT，结果如下表所示：</p><p><img data-proofer-ignore data-src="/img/L-star/case-td5.png" alt="case-td2" /></p><p>当前OT是闭合的，但是并不一致，因为b和a·b等价，但是T(b·b,ε)≠T(a·b·b,ε)。因此，将后缀b·ε=b添加到E中，并填充OT，结果如下图左所示：</p><p><img data-proofer-ignore data-src="/img/L-star/case-td6.png" alt="case-td2" /></p><p>经过验证，该OT是一致且闭合的，于是算法推测出新的模型M3，如上图右所示。模型构建时，根据等价类进行，S中等价的两行可以合并为同一个状态，而S·Σ中某项t与S某项s相同，表示经过t转换后，达到了s对应的状态。</p><p>再次向teacher发起equivalence query，teacher返回yes，表示认可当前模型。L*算法将该DFA状态机模型返回给用户，完成DFA的构建。</p><h1 id="总结">总结</h1><hr /><p>L*算法，其实就是一个<strong>用反例来引导，不断发现新的状态，并不断合并等价状态的过程</strong>。 L*算法只适合推断DFA，但是并不适合推断Mealy Machine。一些其他的算法如LM*算法、TTT算法支持推断Mealy Machine，之后继续学习。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E8%87%AA%E5%8A%A8%E6%9C%BA/'>自动机</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/l-%E7%AE%97%E6%B3%95/" class="post-tag no-text-decoration" >L*算法</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=L* 算法学习 - gtrboy's blog&url=https://gtrboy.github.io/posts/L_star/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=L* 算法学习 - gtrboy's blog&u=https://gtrboy.github.io/posts/L_star/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=L* 算法学习 - gtrboy's blog&url=https://gtrboy.github.io/posts/L_star/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/bus/">物联网设备消息总线机制的使用及安全问题</a><li><a href="/posts/malloc/">malloc源码学习（glibc-2.23）</a><li><a href="/posts/L_star/">L* 算法学习</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/l-%E7%AE%97%E6%B3%95/">L*算法</a> <a class="post-tag" href="/tags/malloc%E6%BA%90%E7%A0%81/">malloc源码</a> <a class="post-tag" href="/tags/pwnable-tw/">pwnable.tw</a> <a class="post-tag" href="/tags/%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/">消息总线</a> <a class="post-tag" href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/CVE-2022-23121/"><div class="card-body"> <span class="timeago small" > May 1 <i class="unloaded">2022-05-01T11:11:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>【翻译】西部数据PR4100 NAS RCE漏洞分析（CVE-2022-23121）</h3><div class="text-muted small"><p> 本文翻译自NCC Group的博客，介绍了该团队在Pwn2Own比赛时针对西部数据PR4100 NAS的远程代码执行漏洞利用的细节。 概述 这篇博客文章介绍了2021年9月由NCC Group的Exploit Development Group（EDG）小组中的Alex Plaskett，Cedric Halbronn以及Aaron Adams三人发现并利用的一个返回值未检测漏洞。...</p></div></div></a></div><div class="card"> <a href="/posts/netatalk/"><div class="card-body"> <span class="timeago small" > Nov 8, 2021 <i class="unloaded">2021-11-08T08:20:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>pwnable.tw CVE-2018-1160</h3><div class="text-muted small"><p> pwnable.tw于2020年新增题目CVE-2018-1160，分值100，题目曾出现在hitcon2019，1day漏洞利用。漏洞源自于一款开源的苹果AFP（Apple Filing Protocol）协议服务器程序Netatalk。和xuanxuan一起做了这道题。 可参考wp如下： CVE-2018-1160: Expanding the original...</p></div></div></a></div><div class="card"> <a href="/posts/malloc/"><div class="card-body"> <span class="timeago small" > Jul 25, 2021 <i class="unloaded">2021-07-25T17:20:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>malloc源码学习（glibc-2.23）</h3><div class="text-muted small"><p> 学习glibc-2.23源码中malloc相关知识，文章顺序和malloc流程相同。本文仅为自己缕清思路用，因此很多细节和基础没有涉及，可能会比较乱。若你看到了这篇文章，推荐看下面的博客，介绍得可能会更加细致。 参考： Linux内存分配小结–malloc、brk、mmap 董哥的黑板报 - 堆漏洞挖掘 堆漏洞挖掘中的bins分类(fastbin、u...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/malloc/" class="btn btn-outline-primary" prompt="Older"><p>malloc源码学习（glibc-2.23）</p></a> <a href="/posts/netatalk/" class="btn btn-outline-primary" prompt="Newer"><p>pwnable.tw CVE-2018-1160</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="">gtrboy</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/l-%E7%AE%97%E6%B3%95/">L*算法</a> <a class="post-tag" href="/tags/malloc%E6%BA%90%E7%A0%81/">malloc源码</a> <a class="post-tag" href="/tags/pwnable-tw/">pwnable.tw</a> <a class="post-tag" href="/tags/%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/">消息总线</a> <a class="post-tag" href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://gtrboy.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script>
